/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  JournalingAssistantPlugin: () => JournalingAssistantPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  journalFolder: "Journal",
  inputsFolder: "Inputs",
  openAIApiKey: "",
  numberOfPastEntries: 3,
  useStreamingResponse: true
};

// src/core/journal/JournalService.ts
var import_obsidian3 = require("obsidian");

// src/utils/helpers.ts
var isSupportedAudioFormat = (file) => {
  const supportedFormats = ["flac", "mp3", "mp4", "mpeg", "mpga", "m4a", "ogg", "wav", "webm"];
  const extension = file.extension.toLowerCase();
  return supportedFormats.includes(extension);
};
var getRecordingEmbedPattern = () => {
  return /!\[\[.+\.(flac|mp3|mp4|mpeg|mpga|m4a|ogg|wav|webm)\]\]/g;
};
var getTodayFileName = () => {
  const date = new Date();
  return date.toISOString().split("T")[0] + ".md";
};

// src/core/ai/services/WhisperService.ts
var WhisperService = class {
  constructor(vault, apiKey) {
    this.vault = vault;
    this.apiKey = apiKey;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  async transcribeFile(audioFile) {
    var _a;
    try {
      if (!this.apiKey) {
        throw new Error("OpenAI API key is required for transcription");
      }
      if (!isSupportedAudioFormat(audioFile)) {
        throw new Error(`Unsupported audio format: ${audioFile.extension}`);
      }
      const formData = new FormData();
      const arrayBuffer = await this.vault.readBinary(audioFile);
      const blob = new Blob([arrayBuffer], { type: `audio/${audioFile.extension}` });
      formData.append("file", blob, `${audioFile.basename}.${audioFile.extension}`);
      formData.append("model", "whisper-1");
      const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: formData
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(((_a = error.error) == null ? void 0 : _a.message) || "Transcription failed");
      }
      const result = await response.json();
      return result.text;
    } catch (error) {
      console.error("Transcription error:", error);
      throw error;
    }
  }
};

// src/core/transcription/TranscriptionService.ts
var import_obsidian = require("obsidian");
var TranscriptionService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.whisperService = new WhisperService(this.app.vault, this.settings.openAIApiKey);
  }
  updateSettings(settings) {
    this.settings = settings;
    this.whisperService.setApiKey(settings.openAIApiKey);
  }
  async transcribeRecordings() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    if (!this.settings.openAIApiKey) {
      new import_obsidian.Notice("OpenAI API key not configured");
      return;
    }
    const editor = activeView.editor;
    const content = editor.getValue();
    const recordingPattern = getRecordingEmbedPattern();
    const recordings = content.match(recordingPattern);
    if (!recordings || recordings.length === 0) {
      new import_obsidian.Notice("No recordings found in the current note");
      return;
    }
    new import_obsidian.Notice("Starting transcription...");
    let updatedContent = content;
    let hasErrors = false;
    try {
      for (const recording of recordings) {
        const fileName = recording.slice(3, -2);
        const file = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
        if (!(file instanceof import_obsidian.TFile)) {
          new import_obsidian.Notice(`Could not find file: ${fileName}`);
          hasErrors = true;
          continue;
        }
        try {
          const transcript = await this.whisperService.transcribeFile(file);
          updatedContent = updatedContent.replace(recording, transcript);
        } catch (error) {
          new import_obsidian.Notice(`Failed to transcribe ${fileName}: ${error.message}`);
          hasErrors = true;
          continue;
        }
      }
      editor.setValue(updatedContent);
      if (hasErrors) {
        new import_obsidian.Notice("Transcription completed with some errors");
      } else {
        new import_obsidian.Notice("Transcription completed successfully");
      }
    } catch (error) {
      new import_obsidian.Notice(`Transcription failed: ${error.message}`);
      console.error("Transcription error:", error);
    }
  }
};

// src/core/summary/SummarizationService.ts
var import_obsidian2 = require("obsidian");

// src/core/ai/prompts/summaryPrompt.ts
var summaryPrompt_default = `As a journaling assistant, analyze this journal entry and create a summary of journaling conversation.

Please follow these guidelines:

1. Think about the highlights of the journal entry that the user would want to remember for the future
2. Retrieve the memories of the user from the journal entry
3. Identify the main themes and insights
4. Highlight key realizations or breakthroughs
5. Note any action items or intentions expressed
6. Preserve the emotional tone of the entry

Focus on extracting the most meaningful elements while maintaining the personal nature of the reflection.`;

// src/core/summary/SummarizationService.ts
var SummarizationService = class {
  constructor(openAIService) {
    this.openAIService = openAIService;
  }
  async summarize(content, useStreaming = false, onChunk) {
    try {
      const prompt = `${summaryPrompt_default}

${content}`;
      return await this.openAIService.makeOpenAIRequest(
        prompt,
        useStreaming ? onChunk : void 0
      );
    } catch (error) {
      new import_obsidian2.Notice(`Error during summarization: ${error.message}`);
      throw error;
    }
  }
};

// src/core/ai/prompts/chatPrompt.ts
var chatPrompt_default = `As an AI journaling assistant, you are helping the user explore their thoughts and goals.
Guiding principles:
\u2022 Maintain a friendly, empathetic tone
\u2022 Please keep it a conversation, not a list of questions, use second person, and use the word "you"
\u2022 The user should feel like they are talking to a wise mentor friend
\u2022 Ask clarifying questions or deeper prompts
\u2022 Avoid steering the user to specific beliefs or conclusions unless they are explicitly asking for it
\u2022 Keep the conversation relevant to the user's stated goals
\u2022 Encourage reflection and actionable outcomes where appropriate
Remember: all interactions take place in the user's note.`;

// src/core/ai/services/ChatService.ts
var ChatService = class {
  constructor(openAIService) {
    this.openAIService = openAIService;
  }
  async chat(transcribedText) {
    const prompt = `${chatPrompt_default}

User: ${transcribedText}

Assistant:`;
    return this.openAIService.makeOpenAIRequest(prompt);
  }
};

// src/core/journal/JournalManager.ts
var JournalManager = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async ensureFolder(folderPath) {
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  getTodayFileName() {
    return getTodayFileName();
  }
  async getPastJournalEntries(count) {
    const folder = this.app.vault.getAbstractFileByPath(this.settings.journalFolder);
    if (!folder)
      return [];
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.journalFolder + "/")).sort((a, b) => b.stat.mtime - a.stat.mtime).slice(1, count + 1);
    const entries = await Promise.all(
      files.map(async (file) => {
        const content = await this.app.vault.read(file);
        return {
          date: file.basename,
          content
        };
      })
    );
    return entries.map((entry) => `Date: ${entry.date}
${entry.content}`);
  }
  async createNewJournalEntry() {
    const fileName = this.getTodayFileName();
    const filePath = `${this.settings.journalFolder}/${fileName}`;
    const initialContent = `# Journal Entry - ${new Date().toLocaleDateString()}

`;
    return await this.app.vault.create(filePath, initialContent);
  }
};

// src/core/ai/prompts/journalPrompt.ts
var journalPrompt_default = `As a friendly journaling guide, analyze these past journal entries and create a thought-provoking prompt 
that encourages deeper self-reflection while maintaining continuity with previous themes and insights. 
Write the outline in a second person, the user should feel like they are talking to a friend.

Before the prompt:
1. Outline the aspects of past entries to allow for better self-reflection, only if there are past entries.
2. Don't make up information, only use the information that is provided in the past entries.
3. Keep a friendly tone, the user should feel like they are talking to a friend
4. Be concise and to the point
5. Always start with "## Recap of past entries", even if there are no past entries.
6. If there's an information that there are no past entries, just write "No past entries available."

The prompt should:
1. Be specific and actionable
2. Keep a friendly tone, the user should feel like they are talking to a friend
3. Don't steer the user into any particular direction, we want to let the user explore their own thoughts and feelings
4. Make the prompt open-ended, in the first message we want to explore how the user is feeling today and what they want to achieve with the journal
5. Inform the user that they can choose one question and continue conversation with the assistant
6. Be concise, if you ask questions, make them a list of bullet points so it's easy to read
7. Start with "## Today's Prompt"

Keep the prompt concise and focused on a single aspect of self-reflection. Please structure your output so it's easy to read and understand.

The final structure should look like this:

## Recap of past entries
<outline of past entries>

## Today's Prompt
<prompt>`;

// src/core/journal/JournalService.ts
var _JournalService = class {
  constructor(app, settings, openAIService) {
    this.app = app;
    this.settings = settings;
    this.openAIService = openAIService;
    this.journalManager = new JournalManager(this.app, this.settings);
    this.whisperService = new WhisperService(this.app.vault, this.settings.openAIApiKey);
    this.summarizationService = new SummarizationService(this.openAIService);
    this.chatService = new ChatService(this.openAIService);
    this.transcriptionService = new TranscriptionService(this.app, this.settings);
  }
  updateSettings(settings) {
    this.settings = settings;
    this.whisperService.setApiKey(settings.openAIApiKey);
    this.transcriptionService.updateSettings(settings);
    this.openAIService.updateSettings(settings);
  }
  async openTodaysJournal() {
    try {
      await this.journalManager.ensureFolder(this.settings.journalFolder);
      const filePath = `${this.settings.journalFolder}/${this.journalManager.getTodayFileName()}`;
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        const loadingNotice = new import_obsidian3.Notice("Generating journal prompt...", 0);
        try {
          file = await this.journalManager.createNewJournalEntry();
          const pastEntries = await this.journalManager.getPastJournalEntries(this.settings.numberOfPastEntries);
          const leaf = this.app.workspace.getLeaf(false);
          await leaf.openFile(file);
          const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
          if (view) {
            if (this.settings.useStreamingResponse) {
              await this.openAIService.makeOpenAIRequest(
                this.createJournalPrompt(pastEntries),
                (chunk) => {
                  const currentContent = view.editor.getValue();
                  view.editor.setValue(currentContent + chunk);
                }
              );
            } else {
              const aiPrompt = await this.openAIService.makeOpenAIRequest(
                this.createJournalPrompt(pastEntries)
              );
              view.editor.setValue(view.editor.getValue() + aiPrompt);
            }
            view.editor.setValue(view.editor.getValue() + "\n\n## Your Journal Response\n\n");
          }
          loadingNotice.hide();
          new import_obsidian3.Notice("Created new journal entry for today");
        } catch (error) {
          new import_obsidian3.Notice("Error generating prompt: " + error.message);
          const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
          if (view) {
            view.editor.setValue(view.editor.getValue() + "\n\n## Your Journal Response\n\n");
          }
        }
      } else {
        const leaf = this.app.workspace.getLeaf(false);
        await leaf.openFile(file);
      }
    } catch (error) {
      new import_obsidian3.Notice("Error opening today's journal: " + error.message);
      console.error("Error opening today's journal:", error);
    }
  }
  createJournalPrompt(pastEntries) {
    const pastEntriesText = pastEntries.length > 0 ? `Past Entries:

${pastEntries.join("\n\n---\n\n")}` : "No past entries available.";
    return `${journalPrompt_default}

${pastEntriesText}`;
  }
  async summarizeJournalingSession() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian3.Notice("Please open a note first");
      return;
    }
    try {
      const originalContent = activeView.editor.getValue();
      const fileName = activeView.file.name;
      const inputPath = `${this.settings.inputsFolder}/${fileName}`;
      await this.journalManager.ensureFolder(this.settings.inputsFolder);
      await this.app.vault.create(inputPath, originalContent);
      await this.transcriptionService.transcribeRecordings();
      const processedContent = activeView.editor.getValue();
      const responseMatch = processedContent.match(_JournalService.JOURNAL_RESPONSE_PATTERN);
      if (!responseMatch) {
        new import_obsidian3.Notice("Could not find journal response section");
        return;
      }
      const userResponse = responseMatch[1].trim();
      let summary;
      if (this.settings.useStreamingResponse) {
        let streamedSummary = "";
        summary = await this.summarizationService.summarize(
          userResponse,
          true,
          (chunk) => {
            streamedSummary += chunk;
            const updatedContent = processedContent.replace(
              _JournalService.JOURNAL_RESPONSE_PATTERN,
              `## Your Journal Response

${streamedSummary}`
            );
            activeView.editor.setValue(updatedContent);
          }
        );
      } else {
        summary = await this.summarizationService.summarize(userResponse);
        const updatedContent = processedContent.replace(
          _JournalService.JOURNAL_RESPONSE_PATTERN,
          `## Your Journal Response

${summary}`
        );
        activeView.editor.setValue(updatedContent);
      }
      new import_obsidian3.Notice("Journal session summarized");
    } catch (error) {
      new import_obsidian3.Notice(`Error: ${error.message}`);
      console.error("Summarization error:", error);
    }
  }
  async chatWithAI() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      new import_obsidian3.Notice("Please open a note first");
      return;
    }
    try {
      await this.transcriptionService.transcribeRecordings();
      const content = activeView.editor.getValue();
      const chatResponse = await this.chatService.chat(content);
      activeView.editor.setValue(
        content + "\n\n---\n## AI Chat\n\n" + chatResponse + "\n\n---\n## Me\n"
      );
      new import_obsidian3.Notice("AI responded in note");
    } catch (error) {
      new import_obsidian3.Notice(`Error during chat: ${error.message}`);
    }
  }
};
var JournalService = _JournalService;
JournalService.JOURNAL_RESPONSE_PATTERN = /## Your Journal Response\s*([\s\S]*$)/;

// src/core/ai/services/OpenAIService.ts
var OpenAIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async makeOpenAIRequest(prompt, onChunk) {
    var _a, _b, _c, _d;
    if (!this.settings.openAIApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.openAIApiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [{ role: "user", content: prompt }],
          temperature: 0.7,
          stream: !!onChunk
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(((_a = error.error) == null ? void 0 : _a.message) || "API request failed");
      }
      if (onChunk) {
        const reader = (_b = response.body) == null ? void 0 : _b.getReader();
        const decoder = new TextDecoder();
        let fullResponse = "";
        if (!reader)
          throw new Error("Response body is null");
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          const chunk = decoder.decode(value);
          const lines = chunk.split("\n").filter((line) => line.trim() !== "");
          for (const line of lines) {
            if (line.includes("[DONE]"))
              continue;
            if (!line.startsWith("data:"))
              continue;
            try {
              const json = JSON.parse(line.slice(5));
              const content = (_d = (_c = json.choices[0]) == null ? void 0 : _c.delta) == null ? void 0 : _d.content;
              if (content) {
                fullResponse += content;
                onChunk(content);
              }
            } catch (e) {
              console.warn("Failed to parse streaming response:", e);
            }
          }
        }
        return fullResponse;
      }
      const data = await response.json();
      return data.choices[0].message.content;
    } catch (error) {
      console.error("OpenAI API error:", error);
      throw error;
    }
  }
};

// src/settings/SettingTab.ts
var import_obsidian4 = require("obsidian");
var JournalingAssistantSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Journaling Assistant Settings" });
    new import_obsidian4.Setting(containerEl).setName("Journal Folder").setDesc("The folder where your journal entries will be stored").addText((text) => text.setPlaceholder("Journal").setValue(this.plugin.settings.journalFolder).onChange(async (value) => {
      this.plugin.settings.journalFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Journal Inputs Folder").setDesc("The folder where your journal inputs will be stored").addText((text) => text.setPlaceholder("Inputs").setValue(this.plugin.settings.inputsFolder).onChange(async (value) => {
      this.plugin.settings.inputsFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating prompts and summaries").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
      this.plugin.settings.openAIApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Number of Past Entries").setDesc("Number of past journal entries to consider when generating prompts").addSlider((slider) => slider.setLimits(0, 10, 1).setValue(this.plugin.settings.numberOfPastEntries).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.numberOfPastEntries = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Use Streaming Response").setDesc("Stream AI responses in real-time (recommended for better experience)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useStreamingResponse).onChange(async (value) => {
      this.plugin.settings.useStreamingResponse = value;
      await this.plugin.saveSettings();
    }));
  }
};

// main.ts
var JournalingAssistantPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.openAIService = new OpenAIService(this.settings);
    this.transcriptionService = new TranscriptionService(this.app, this.settings);
    this.journalService = new JournalService(
      this.app,
      this.settings,
      this.openAIService
    );
    this.addSettingTab(new JournalingAssistantSettingTab(this.app, this));
    this.addRibbonIcon("bot", "Journaling Assistant", (evt) => {
      const menu = new import_obsidian5.Menu();
      menu.addItem(
        (item) => item.setTitle("Open Today's Journal").setIcon("calendar-plus").onClick(() => {
          this.journalService.openTodaysJournal();
        })
      );
      menu.addItem(
        (item) => item.setTitle("Chat with AI").setIcon("message-square").onClick(() => {
          this.journalService.chatWithAI();
        })
      );
      menu.addItem(
        (item) => item.setTitle("Summarize Journaling Session").setIcon("book").onClick(() => {
          this.journalService.summarizeJournalingSession();
        })
      );
      menu.showAtMouseEvent(evt);
    });
    this.addCommands();
  }
  addCommands() {
    this.addCommand({
      id: "open-todays-journal",
      name: "Open Today's Journal",
      callback: async () => {
        await this.journalService.openTodaysJournal();
      }
    });
    this.addCommand({
      id: "transcribe-recordings",
      name: "Transcribe Recordings",
      callback: async () => {
        await this.transcriptionService.transcribeRecordings();
      }
    });
    this.addCommand({
      id: "summarize-journal",
      name: "Summarize Journaling Session",
      callback: async () => {
        await this.journalService.summarizeJournalingSession();
      }
    });
    this.addCommand({
      id: "chat-with-ai",
      name: "Chat with AI",
      callback: async () => {
        await this.journalService.chatWithAI();
      }
    });
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.openAIService.updateSettings(this.settings);
    this.transcriptionService.updateSettings(this.settings);
    this.journalService.updateSettings(this.settings);
  }
  onunload() {
    console.log("Unloading Journaling Assistant Plugin...");
  }
};
var main_default = JournalingAssistantPlugin;
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL2NvcmUvam91cm5hbC9Kb3VybmFsU2VydmljZS50cyIsICJzcmMvdXRpbHMvaGVscGVycy50cyIsICJzcmMvY29yZS9haS9zZXJ2aWNlcy9XaGlzcGVyU2VydmljZS50cyIsICJzcmMvY29yZS90cmFuc2NyaXB0aW9uL1RyYW5zY3JpcHRpb25TZXJ2aWNlLnRzIiwgInNyYy9jb3JlL3N1bW1hcnkvU3VtbWFyaXphdGlvblNlcnZpY2UudHMiLCAic3JjL2NvcmUvYWkvcHJvbXB0cy9zdW1tYXJ5UHJvbXB0LnRzIiwgInNyYy9jb3JlL2FpL3Byb21wdHMvY2hhdFByb21wdC50cyIsICJzcmMvY29yZS9haS9zZXJ2aWNlcy9DaGF0U2VydmljZS50cyIsICJzcmMvY29yZS9qb3VybmFsL0pvdXJuYWxNYW5hZ2VyLnRzIiwgInNyYy9jb3JlL2FpL3Byb21wdHMvam91cm5hbFByb21wdC50cyIsICJzcmMvY29yZS9haS9zZXJ2aWNlcy9PcGVuQUlTZXJ2aWNlLnRzIiwgInNyYy9zZXR0aW5ncy9TZXR0aW5nVGFiLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBBcHAsIFBsdWdpbiwgTm90aWNlLCBNZW51IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi9zcmMvdHlwZXMnO1xuaW1wb3J0IHsgSm91cm5hbFNlcnZpY2UgfSBmcm9tICcuL3NyYy9jb3JlL2pvdXJuYWwvSm91cm5hbFNlcnZpY2UnO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4vc3JjL2NvcmUvYWkvc2VydmljZXMvT3BlbkFJU2VydmljZSc7XG5pbXBvcnQgeyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ1RhYiB9IGZyb20gJy4vc3JjL3NldHRpbmdzL1NldHRpbmdUYWInO1xuaW1wb3J0IHsgVHJhbnNjcmlwdGlvblNlcnZpY2UgfSBmcm9tICcuL3NyYy9jb3JlL3RyYW5zY3JpcHRpb24vVHJhbnNjcmlwdGlvblNlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgSm91cm5hbGluZ0Fzc2lzdGFudFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncztcbiAgICBwcml2YXRlIGpvdXJuYWxTZXJ2aWNlOiBKb3VybmFsU2VydmljZTtcbiAgICBwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2U7XG4gICAgcHJpdmF0ZSB0cmFuc2NyaXB0aW9uU2VydmljZTogVHJhbnNjcmlwdGlvblNlcnZpY2U7XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbml0aWFsaXplIHNlcnZpY2VzIHdpdGggdGhlIG5ldyBzdHJ1Y3R1cmVcbiAgICAgICAgdGhpcy5vcGVuQUlTZXJ2aWNlID0gbmV3IE9wZW5BSVNlcnZpY2UodGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudHJhbnNjcmlwdGlvblNlcnZpY2UgPSBuZXcgVHJhbnNjcmlwdGlvblNlcnZpY2UodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmpvdXJuYWxTZXJ2aWNlID0gbmV3IEpvdXJuYWxTZXJ2aWNlKFxuICAgICAgICAgICAgdGhpcy5hcHAsIFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncywgXG4gICAgICAgICAgICB0aGlzLm9wZW5BSVNlcnZpY2VcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgdGFiXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgcmliYm9uIGljb24gd2l0aCBtZW51XG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignYm90JywgJ0pvdXJuYWxpbmcgQXNzaXN0YW50JywgKGV2dDogTW91c2VFdmVudCB8IFBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVudSA9IG5ldyBNZW51KCk7XG4gICAgICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+XG4gICAgICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICAgICAgICAgICAuc2V0VGl0bGUoXCJPcGVuIFRvZGF5J3MgSm91cm5hbFwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignY2FsZW5kYXItcGx1cycpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuam91cm5hbFNlcnZpY2Uub3BlblRvZGF5c0pvdXJuYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+XG4gICAgICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICAgICAgICAgICAuc2V0VGl0bGUoXCJDaGF0IHdpdGggQUlcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ21lc3NhZ2Utc3F1YXJlJylcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5qb3VybmFsU2VydmljZS5jaGF0V2l0aEFJKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgLnNldFRpdGxlKFwiU3VtbWFyaXplIEpvdXJuYWxpbmcgU2Vzc2lvblwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignYm9vaycpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuam91cm5hbFNlcnZpY2Uuc3VtbWFyaXplSm91cm5hbGluZ1Nlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtZW51LnNob3dBdE1vdXNlRXZlbnQoZXZ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIC8vIENvbW1hbmQgdG8gb3BlbiB0b2RheSdzIGpvdXJuYWxcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnb3Blbi10b2RheXMtam91cm5hbCcsXG4gICAgICAgICAgICBuYW1lOiAnT3BlbiBUb2RheVxcJ3MgSm91cm5hbCcsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuam91cm5hbFNlcnZpY2Uub3BlblRvZGF5c0pvdXJuYWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbW1hbmQgdG8gdHJhbnNjcmliZSByZWNvcmRpbmdzXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ3RyYW5zY3JpYmUtcmVjb3JkaW5ncycsXG4gICAgICAgICAgICBuYW1lOiAnVHJhbnNjcmliZSBSZWNvcmRpbmdzJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc2NyaXB0aW9uU2VydmljZS50cmFuc2NyaWJlUmVjb3JkaW5ncygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29tbWFuZCB0byBzdW1tYXJpemUgam91cm5hbFxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdzdW1tYXJpemUtam91cm5hbCcsXG4gICAgICAgICAgICBuYW1lOiAnU3VtbWFyaXplIEpvdXJuYWxpbmcgU2Vzc2lvbicsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuam91cm5hbFNlcnZpY2Uuc3VtbWFyaXplSm91cm5hbGluZ1Nlc3Npb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbW1hbmQgdG8gY2hhdCB3aXRoIEFJXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ2NoYXQtd2l0aC1haScsXG4gICAgICAgICAgICBuYW1lOiAnQ2hhdCB3aXRoIEFJJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5qb3VybmFsU2VydmljZS5jaGF0V2l0aEFJKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmxvYWREYXRhKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBkYXRhKTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgc2VydmljZXMgd2l0aCBuZXcgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5vcGVuQUlTZXJ2aWNlLnVwZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpcHRpb25TZXJ2aWNlLnVwZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmpvdXJuYWxTZXJ2aWNlLnVwZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVubG9hZGluZyBKb3VybmFsaW5nIEFzc2lzdGFudCBQbHVnaW4uLi5cIik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBKb3VybmFsaW5nQXNzaXN0YW50UGx1Z2luO1xuIiwgImV4cG9ydCBpbnRlcmZhY2UgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzIHtcbiAgICBqb3VybmFsRm9sZGVyOiBzdHJpbmc7XG4gICAgaW5wdXRzRm9sZGVyOiBzdHJpbmc7XG4gICAgb3BlbkFJQXBpS2V5OiBzdHJpbmc7XG4gICAgbnVtYmVyT2ZQYXN0RW50cmllczogbnVtYmVyO1xuICAgIHVzZVN0cmVhbWluZ1Jlc3BvbnNlOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzID0ge1xuICAgIGpvdXJuYWxGb2xkZXI6ICdKb3VybmFsJyxcbiAgICBpbnB1dHNGb2xkZXI6ICdJbnB1dHMnLFxuICAgIG9wZW5BSUFwaUtleTogJycsXG4gICAgbnVtYmVyT2ZQYXN0RW50cmllczogMyxcbiAgICB1c2VTdHJlYW1pbmdSZXNwb25zZTogdHJ1ZSxcbn07ICIsICJpbXBvcnQgeyBBcHAsIFRGaWxlLCBOb3RpY2UsIE1hcmtkb3duVmlldyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IElKb3VybmFsU2VydmljZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4uL2FpL3NlcnZpY2VzL09wZW5BSVNlcnZpY2UnO1xuaW1wb3J0IHsgV2hpc3BlclNlcnZpY2UgfSBmcm9tICcuLi9haS9zZXJ2aWNlcy9XaGlzcGVyU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2NyaXB0aW9uU2VydmljZSB9IGZyb20gJy4uL3RyYW5zY3JpcHRpb24vVHJhbnNjcmlwdGlvblNlcnZpY2UnO1xuaW1wb3J0IHsgU3VtbWFyaXphdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zdW1tYXJ5L1N1bW1hcml6YXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IENoYXRTZXJ2aWNlIH0gZnJvbSAnLi4vYWkvc2VydmljZXMvQ2hhdFNlcnZpY2UnO1xuaW1wb3J0IHsgSm91cm5hbE1hbmFnZXIgfSBmcm9tICcuL0pvdXJuYWxNYW5hZ2VyJztcbmltcG9ydCBqb3VybmFsUHJvbXB0IGZyb20gJy4uL2FpL3Byb21wdHMvam91cm5hbFByb21wdCc7XG5cbmV4cG9ydCBjbGFzcyBKb3VybmFsU2VydmljZSBpbXBsZW1lbnRzIElKb3VybmFsU2VydmljZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgSk9VUk5BTF9SRVNQT05TRV9QQVRURVJOID0gLyMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxccyooW1xcc1xcU10qJCkvO1xuICAgIHByaXZhdGUgam91cm5hbE1hbmFnZXI6IEpvdXJuYWxNYW5hZ2VyO1xuICAgIHByaXZhdGUgd2hpc3BlclNlcnZpY2U6IFdoaXNwZXJTZXJ2aWNlO1xuICAgIHByaXZhdGUgc3VtbWFyaXphdGlvblNlcnZpY2U6IFN1bW1hcml6YXRpb25TZXJ2aWNlO1xuICAgIHByaXZhdGUgY2hhdFNlcnZpY2U6IENoYXRTZXJ2aWNlO1xuICAgIHByaXZhdGUgdHJhbnNjcmlwdGlvblNlcnZpY2U6IFRyYW5zY3JpcHRpb25TZXJ2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgYXBwOiBBcHAsXG4gICAgICAgIHByaXZhdGUgc2V0dGluZ3M6IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyxcbiAgICAgICAgcHJpdmF0ZSBvcGVuQUlTZXJ2aWNlOiBPcGVuQUlTZXJ2aWNlXG4gICAgKSB7XG4gICAgICAgIHRoaXMuam91cm5hbE1hbmFnZXIgPSBuZXcgSm91cm5hbE1hbmFnZXIodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLndoaXNwZXJTZXJ2aWNlID0gbmV3IFdoaXNwZXJTZXJ2aWNlKHRoaXMuYXBwLnZhdWx0LCB0aGlzLnNldHRpbmdzLm9wZW5BSUFwaUtleSk7XG4gICAgICAgIHRoaXMuc3VtbWFyaXphdGlvblNlcnZpY2UgPSBuZXcgU3VtbWFyaXphdGlvblNlcnZpY2UodGhpcy5vcGVuQUlTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jaGF0U2VydmljZSA9IG5ldyBDaGF0U2VydmljZSh0aGlzLm9wZW5BSVNlcnZpY2UpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpcHRpb25TZXJ2aWNlID0gbmV3IFRyYW5zY3JpcHRpb25TZXJ2aWNlKHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTZXR0aW5ncyhzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy53aGlzcGVyU2VydmljZS5zZXRBcGlLZXkoc2V0dGluZ3Mub3BlbkFJQXBpS2V5KTtcbiAgICAgICAgdGhpcy50cmFuc2NyaXB0aW9uU2VydmljZS51cGRhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMub3BlbkFJU2VydmljZS51cGRhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgYXN5bmMgb3BlblRvZGF5c0pvdXJuYWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmpvdXJuYWxNYW5hZ2VyLmVuc3VyZUZvbGRlcih0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGAke3RoaXMuc2V0dGluZ3Muam91cm5hbEZvbGRlcn0vJHt0aGlzLmpvdXJuYWxNYW5hZ2VyLmdldFRvZGF5RmlsZU5hbWUoKX1gO1xuICAgICAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nTm90aWNlID0gbmV3IE5vdGljZSgnR2VuZXJhdGluZyBqb3VybmFsIHByb21wdC4uLicsIDApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgam91cm5hbCBlbnRyeVxuICAgICAgICAgICAgICAgICAgICBmaWxlID0gYXdhaXQgdGhpcy5qb3VybmFsTWFuYWdlci5jcmVhdGVOZXdKb3VybmFsRW50cnkoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBwYXN0IGVudHJpZXMgZm9yIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdEVudHJpZXMgPSBhd2FpdCB0aGlzLmpvdXJuYWxNYW5hZ2VyLmdldFBhc3RKb3VybmFsRW50cmllcyh0aGlzLnNldHRpbmdzLm51bWJlck9mUGFzdEVudHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUgYXMgVEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy51c2VTdHJlYW1pbmdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmVhbSB0aGUgQUkgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9wZW5BSVNlcnZpY2UubWFrZU9wZW5BSVJlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlSm91cm5hbFByb21wdChwYXN0RW50cmllcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRlbnQgPSB2aWV3LmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5lZGl0b3Iuc2V0VmFsdWUoY3VycmVudENvbnRlbnQgKyBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY29tcGxldGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhaVByb21wdCA9IGF3YWl0IHRoaXMub3BlbkFJU2VydmljZS5tYWtlT3BlbkFJUmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVKb3VybmFsUHJvbXB0KHBhc3RFbnRyaWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5lZGl0b3Iuc2V0VmFsdWUodmlldy5lZGl0b3IuZ2V0VmFsdWUoKSArIGFpUHJvbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHJlc3BvbnNlIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZWRpdG9yLnNldFZhbHVlKHZpZXcuZWRpdG9yLmdldFZhbHVlKCkgKyAnXFxuXFxuIyMgWW91ciBKb3VybmFsIFJlc3BvbnNlXFxuXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdOb3RpY2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdDcmVhdGVkIG5ldyBqb3VybmFsIGVudHJ5IGZvciB0b2RheScpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIGdlbmVyYXRpbmcgcHJvbXB0OiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5lZGl0b3Iuc2V0VmFsdWUodmlldy5lZGl0b3IuZ2V0VmFsdWUoKSArICdcXG5cXG4jIyBZb3VyIEpvdXJuYWwgUmVzcG9uc2VcXG5cXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUgYXMgVEZpbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdFcnJvciBvcGVuaW5nIHRvZGF5XFwncyBqb3VybmFsOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvcGVuaW5nIHRvZGF5XFwncyBqb3VybmFsOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlSm91cm5hbFByb21wdChwYXN0RW50cmllczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBwYXN0RW50cmllc1RleHQgPSBwYXN0RW50cmllcy5sZW5ndGggPiAwIFxuICAgICAgICAgICAgPyBgUGFzdCBFbnRyaWVzOlxcblxcbiR7cGFzdEVudHJpZXMuam9pbignXFxuXFxuLS0tXFxuXFxuJyl9YFxuICAgICAgICAgICAgOiAnTm8gcGFzdCBlbnRyaWVzIGF2YWlsYWJsZS4nO1xuXG4gICAgICAgIHJldHVybiBgJHtqb3VybmFsUHJvbXB0fVxcblxcbiR7cGFzdEVudHJpZXNUZXh0fWA7XG4gICAgfVxuXG4gICAgYXN5bmMgc3VtbWFyaXplSm91cm5hbGluZ1Nlc3Npb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBpZiAoIWFjdGl2ZVZpZXcgfHwgIWFjdGl2ZVZpZXcuZmlsZSkge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBub3RlIGZpcnN0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBjb250ZW50XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbENvbnRlbnQgPSBhY3RpdmVWaWV3LmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBhY3RpdmVWaWV3LmZpbGUubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0UGF0aCA9IGAke3RoaXMuc2V0dGluZ3MuaW5wdXRzRm9sZGVyfS8ke2ZpbGVOYW1lfWA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuam91cm5hbE1hbmFnZXIuZW5zdXJlRm9sZGVyKHRoaXMuc2V0dGluZ3MuaW5wdXRzRm9sZGVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShpbnB1dFBhdGgsIG9yaWdpbmFsQ29udGVudCk7XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgY29udGVudCAodHJhbnNjcmliZSByZWNvcmRpbmdzIGlmIGFueSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudHJhbnNjcmlwdGlvblNlcnZpY2UudHJhbnNjcmliZVJlY29yZGluZ3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZENvbnRlbnQgPSBhY3RpdmVWaWV3LmVkaXRvci5nZXRWYWx1ZSgpO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHVzZXIncyByZXNwb25zZSBzZWN0aW9uIC0gaW1wcm92ZWQgcmVnZXggcGF0dGVyblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VNYXRjaCA9IHByb2Nlc3NlZENvbnRlbnQubWF0Y2goSm91cm5hbFNlcnZpY2UuSk9VUk5BTF9SRVNQT05TRV9QQVRURVJOKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VNYXRjaCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0NvdWxkIG5vdCBmaW5kIGpvdXJuYWwgcmVzcG9uc2Ugc2VjdGlvbicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdXNlclJlc3BvbnNlID0gcmVzcG9uc2VNYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICBsZXQgc3VtbWFyeTogc3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy51c2VTdHJlYW1pbmdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdHJlYW1lZFN1bW1hcnkgPSAnJztcbiAgICAgICAgICAgICAgICBzdW1tYXJ5ID0gYXdhaXQgdGhpcy5zdW1tYXJpemF0aW9uU2VydmljZS5zdW1tYXJpemUoXG4gICAgICAgICAgICAgICAgICAgIHVzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1lZFN1bW1hcnkgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudCA9IHByb2Nlc3NlZENvbnRlbnQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBKb3VybmFsU2VydmljZS5KT1VSTkFMX1JFU1BPTlNFX1BBVFRFUk4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbiR7c3RyZWFtZWRTdW1tYXJ5fWBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVWaWV3LmVkaXRvci5zZXRWYWx1ZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdW1tYXJ5ID0gYXdhaXQgdGhpcy5zdW1tYXJpemF0aW9uU2VydmljZS5zdW1tYXJpemUodXNlclJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudCA9IHByb2Nlc3NlZENvbnRlbnQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgSm91cm5hbFNlcnZpY2UuSk9VUk5BTF9SRVNQT05TRV9QQVRURVJOLFxuICAgICAgICAgICAgICAgICAgICBgIyMgWW91ciBKb3VybmFsIFJlc3BvbnNlXFxuXFxuJHtzdW1tYXJ5fWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGFjdGl2ZVZpZXcuZWRpdG9yLnNldFZhbHVlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3IE5vdGljZSgnSm91cm5hbCBzZXNzaW9uIHN1bW1hcml6ZWQnKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1bW1hcml6YXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgY2hhdFdpdGhBSSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGlmICghYWN0aXZlVmlldykge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBub3RlIGZpcnN0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJhbnNjcmliZSBhbnkgYXVkaW8gcmVjb3JkaW5nc1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc2NyaXB0aW9uU2VydmljZS50cmFuc2NyaWJlUmVjb3JkaW5ncygpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdXBkYXRlZCBjb250ZW50IGFuZCBjaGF0XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYWN0aXZlVmlldy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXRSZXNwb25zZSA9IGF3YWl0IHRoaXMuY2hhdFNlcnZpY2UuY2hhdChjb250ZW50KTtcblxuICAgICAgICAgICAgLy8gQXBwZW5kIEFJJ3MgcmVzcG9uc2VcbiAgICAgICAgICAgIGFjdGl2ZVZpZXcuZWRpdG9yLnNldFZhbHVlKFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKyAnXFxuXFxuLS0tXFxuIyMgQUkgQ2hhdFxcblxcbicgKyBjaGF0UmVzcG9uc2UgKyAnXFxuXFxuLS0tXFxuIyMgTWVcXG4nXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBuZXcgTm90aWNlKCdBSSByZXNwb25kZWQgaW4gbm90ZScpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBFcnJvciBkdXJpbmcgY2hhdDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxufSAiLCAiaW1wb3J0IHsgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZEF1ZGlvRm9ybWF0ID0gKGZpbGU6IFRGaWxlKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3Qgc3VwcG9ydGVkRm9ybWF0cyA9IFsnZmxhYycsICdtcDMnLCAnbXA0JywgJ21wZWcnLCAnbXBnYScsICdtNGEnLCAnb2dnJywgJ3dhdicsICd3ZWJtJ107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZmlsZS5leHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gc3VwcG9ydGVkRm9ybWF0cy5pbmNsdWRlcyhleHRlbnNpb24pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFJlY29yZGluZ0VtYmVkUGF0dGVybiA9ICgpOiBSZWdFeHAgPT4ge1xuICAgIHJldHVybiAvIVxcW1xcWy4rXFwuKGZsYWN8bXAzfG1wNHxtcGVnfG1wZ2F8bTRhfG9nZ3x3YXZ8d2VibSlcXF1cXF0vZztcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUb2RheUZpbGVOYW1lID0gKCk6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdICsgJy5tZCc7IC8vIEZvcm1hdDogWVlZWS1NTS1ERC5tZFxufTsgIiwgImltcG9ydCB7IFRGaWxlLCBWYXVsdCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IElXaGlzcGVyU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgaXNTdXBwb3J0ZWRBdWRpb0Zvcm1hdCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2hlbHBlcnMnO1xuXG5leHBvcnQgY2xhc3MgV2hpc3BlclNlcnZpY2UgaW1wbGVtZW50cyBJV2hpc3BlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHZhdWx0OiBWYXVsdCxcbiAgICAgICAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZ1xuICAgICkge31cblxuICAgIHNldEFwaUtleShhcGlLZXk6IHN0cmluZykge1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG5cbiAgICBhc3luYyB0cmFuc2NyaWJlRmlsZShhdWRpb0ZpbGU6IFRGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBBUEkga2V5IGlzIHJlcXVpcmVkIGZvciB0cmFuc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNTdXBwb3J0ZWRBdWRpb0Zvcm1hdChhdWRpb0ZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhdWRpbyBmb3JtYXQ6ICR7YXVkaW9GaWxlLmV4dGVuc2lvbn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkQmluYXJ5KGF1ZGlvRmlsZSk7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwgeyB0eXBlOiBgYXVkaW8vJHthdWRpb0ZpbGUuZXh0ZW5zaW9ufWAgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCBgJHthdWRpb0ZpbGUuYmFzZW5hbWV9LiR7YXVkaW9GaWxlLmV4dGVuc2lvbn1gKTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnbW9kZWwnLCAnd2hpc3Blci0xJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmVycm9yPy5tZXNzYWdlIHx8ICdUcmFuc2NyaXB0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUcmFuc2NyaXB0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufSAiLCAiaW1wb3J0IHsgTm90aWNlLCBNYXJrZG93blZpZXcsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgV2hpc3BlclNlcnZpY2UgfSBmcm9tICcuLi9haS9zZXJ2aWNlcy9XaGlzcGVyU2VydmljZSc7XG5pbXBvcnQgeyBJVHJhbnNjcmlwdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IGdldFJlY29yZGluZ0VtYmVkUGF0dGVybiwgaXNTdXBwb3J0ZWRBdWRpb0Zvcm1hdCB9IGZyb20gJy4uLy4uL3V0aWxzL2hlbHBlcnMnO1xuaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2NyaXB0aW9uU2VydmljZSBpbXBsZW1lbnRzIElUcmFuc2NyaXB0aW9uU2VydmljZSB7XG4gICAgcHJpdmF0ZSB3aGlzcGVyU2VydmljZTogV2hpc3BlclNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBhcHA6IEFwcCxcbiAgICAgICAgcHJpdmF0ZSBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzXG4gICAgKSB7XG4gICAgICAgIHRoaXMud2hpc3BlclNlcnZpY2UgPSBuZXcgV2hpc3BlclNlcnZpY2UodGhpcy5hcHAudmF1bHQsIHRoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5KTtcbiAgICB9XG5cbiAgICB1cGRhdGVTZXR0aW5ncyhzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy53aGlzcGVyU2VydmljZS5zZXRBcGlLZXkoc2V0dGluZ3Mub3BlbkFJQXBpS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyB0cmFuc2NyaWJlUmVjb3JkaW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGlmICghYWN0aXZlVmlldykge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBub3RlIGZpcnN0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVjb3JkaW5nUGF0dGVybiA9IGdldFJlY29yZGluZ0VtYmVkUGF0dGVybigpO1xuICAgICAgICBjb25zdCByZWNvcmRpbmdzID0gY29udGVudC5tYXRjaChyZWNvcmRpbmdQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoIXJlY29yZGluZ3MgfHwgcmVjb3JkaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIHJlY29yZGluZ3MgZm91bmQgaW4gdGhlIGN1cnJlbnQgbm90ZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IE5vdGljZSgnU3RhcnRpbmcgdHJhbnNjcmlwdGlvbi4uLicpO1xuXG4gICAgICAgIGxldCB1cGRhdGVkQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGxldCBoYXNFcnJvcnMgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmRpbmcgb2YgcmVjb3JkaW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVjb3JkaW5nLnNsaWNlKDMsIC0yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChmaWxlTmFtZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3VsZCBub3QgZmluZCBmaWxlOiAke2ZpbGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gYXdhaXQgdGhpcy53aGlzcGVyU2VydmljZS50cmFuc2NyaWJlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSB1cGRhdGVkQ29udGVudC5yZXBsYWNlKHJlY29yZGluZywgdHJhbnNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIHRyYW5zY3JpYmUgJHtmaWxlTmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3Iuc2V0VmFsdWUodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnVHJhbnNjcmlwdGlvbiBjb21wbGV0ZWQgd2l0aCBzb21lIGVycm9ycycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdUcmFuc2NyaXB0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRyYW5zY3JpcHRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUcmFuc2NyaXB0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn0gIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IE9wZW5BSVNlcnZpY2UgfSBmcm9tICcuLi9haS9zZXJ2aWNlcy9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IElTdW1tYXJpemF0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHN1bW1hcnlQcm9tcHQgZnJvbSAnLi4vYWkvcHJvbXB0cy9zdW1tYXJ5UHJvbXB0JztcblxuZXhwb3J0IGNsYXNzIFN1bW1hcml6YXRpb25TZXJ2aWNlIGltcGxlbWVudHMgSVN1bW1hcml6YXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2UpIHt9XG5cbiAgICBhc3luYyBzdW1tYXJpemUoXG4gICAgICAgIGNvbnRlbnQ6IHN0cmluZywgXG4gICAgICAgIHVzZVN0cmVhbWluZzogYm9vbGVhbiA9IGZhbHNlLFxuICAgICAgICBvbkNodW5rPzogKGNodW5rOiBzdHJpbmcpID0+IHZvaWRcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gYCR7c3VtbWFyeVByb21wdH1cXG5cXG4ke2NvbnRlbnR9YDtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9wZW5BSVNlcnZpY2UubWFrZU9wZW5BSVJlcXVlc3QoXG4gICAgICAgICAgICAgICAgcHJvbXB0LCBcbiAgICAgICAgICAgICAgICB1c2VTdHJlYW1pbmcgPyBvbkNodW5rIDogdW5kZWZpbmVkXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBFcnJvciBkdXJpbmcgc3VtbWFyaXphdGlvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59ICIsICJleHBvcnQgZGVmYXVsdCBgQXMgYSBqb3VybmFsaW5nIGFzc2lzdGFudCwgYW5hbHl6ZSB0aGlzIGpvdXJuYWwgZW50cnkgYW5kIGNyZWF0ZSBhIHN1bW1hcnkgb2Ygam91cm5hbGluZyBjb252ZXJzYXRpb24uXG5cblBsZWFzZSBmb2xsb3cgdGhlc2UgZ3VpZGVsaW5lczpcblxuMS4gVGhpbmsgYWJvdXQgdGhlIGhpZ2hsaWdodHMgb2YgdGhlIGpvdXJuYWwgZW50cnkgdGhhdCB0aGUgdXNlciB3b3VsZCB3YW50IHRvIHJlbWVtYmVyIGZvciB0aGUgZnV0dXJlXG4yLiBSZXRyaWV2ZSB0aGUgbWVtb3JpZXMgb2YgdGhlIHVzZXIgZnJvbSB0aGUgam91cm5hbCBlbnRyeVxuMy4gSWRlbnRpZnkgdGhlIG1haW4gdGhlbWVzIGFuZCBpbnNpZ2h0c1xuNC4gSGlnaGxpZ2h0IGtleSByZWFsaXphdGlvbnMgb3IgYnJlYWt0aHJvdWdoc1xuNS4gTm90ZSBhbnkgYWN0aW9uIGl0ZW1zIG9yIGludGVudGlvbnMgZXhwcmVzc2VkXG42LiBQcmVzZXJ2ZSB0aGUgZW1vdGlvbmFsIHRvbmUgb2YgdGhlIGVudHJ5XG5cbkZvY3VzIG9uIGV4dHJhY3RpbmcgdGhlIG1vc3QgbWVhbmluZ2Z1bCBlbGVtZW50cyB3aGlsZSBtYWludGFpbmluZyB0aGUgcGVyc29uYWwgbmF0dXJlIG9mIHRoZSByZWZsZWN0aW9uLmA7ICIsICJleHBvcnQgZGVmYXVsdCBgQXMgYW4gQUkgam91cm5hbGluZyBhc3Npc3RhbnQsIHlvdSBhcmUgaGVscGluZyB0aGUgdXNlciBleHBsb3JlIHRoZWlyIHRob3VnaHRzIGFuZCBnb2Fscy5cbkd1aWRpbmcgcHJpbmNpcGxlczpcblx1MjAyMiBNYWludGFpbiBhIGZyaWVuZGx5LCBlbXBhdGhldGljIHRvbmVcblx1MjAyMiBQbGVhc2Uga2VlcCBpdCBhIGNvbnZlcnNhdGlvbiwgbm90IGEgbGlzdCBvZiBxdWVzdGlvbnMsIHVzZSBzZWNvbmQgcGVyc29uLCBhbmQgdXNlIHRoZSB3b3JkIFwieW91XCJcblx1MjAyMiBUaGUgdXNlciBzaG91bGQgZmVlbCBsaWtlIHRoZXkgYXJlIHRhbGtpbmcgdG8gYSB3aXNlIG1lbnRvciBmcmllbmRcblx1MjAyMiBBc2sgY2xhcmlmeWluZyBxdWVzdGlvbnMgb3IgZGVlcGVyIHByb21wdHNcblx1MjAyMiBBdm9pZCBzdGVlcmluZyB0aGUgdXNlciB0byBzcGVjaWZpYyBiZWxpZWZzIG9yIGNvbmNsdXNpb25zIHVubGVzcyB0aGV5IGFyZSBleHBsaWNpdGx5IGFza2luZyBmb3IgaXRcblx1MjAyMiBLZWVwIHRoZSBjb252ZXJzYXRpb24gcmVsZXZhbnQgdG8gdGhlIHVzZXIncyBzdGF0ZWQgZ29hbHNcblx1MjAyMiBFbmNvdXJhZ2UgcmVmbGVjdGlvbiBhbmQgYWN0aW9uYWJsZSBvdXRjb21lcyB3aGVyZSBhcHByb3ByaWF0ZVxuUmVtZW1iZXI6IGFsbCBpbnRlcmFjdGlvbnMgdGFrZSBwbGFjZSBpbiB0aGUgdXNlcidzIG5vdGUuYDsgIiwgImltcG9ydCB7IE9wZW5BSVNlcnZpY2UgfSBmcm9tICcuL09wZW5BSVNlcnZpY2UnO1xuaW1wb3J0IGNoYXRQcm9tcHQgZnJvbSAnLi4vcHJvbXB0cy9jaGF0UHJvbXB0JztcblxuZXhwb3J0IGNsYXNzIENoYXRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2UpIHt9XG5cbiAgICBhc3luYyBjaGF0KHRyYW5zY3JpYmVkVGV4dDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gYCR7Y2hhdFByb21wdH1cXG5cXG5Vc2VyOiAke3RyYW5zY3JpYmVkVGV4dH1cXG5cXG5Bc3Npc3RhbnQ6YDtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbkFJU2VydmljZS5tYWtlT3BlbkFJUmVxdWVzdChwcm9tcHQpO1xuICAgIH1cbn0gIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRUb2RheUZpbGVOYW1lIH0gZnJvbSAnLi4vLi4vdXRpbHMvaGVscGVycyc7XG5cbmV4cG9ydCBjbGFzcyBKb3VybmFsTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgYXBwOiBBcHAsXG4gICAgICAgIHByaXZhdGUgc2V0dGluZ3M6IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5nc1xuICAgICkge31cblxuICAgIGFzeW5jIGVuc3VyZUZvbGRlcihmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMoZm9sZGVyUGF0aCkpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIoZm9sZGVyUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRUb2RheUZpbGVOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBnZXRUb2RheUZpbGVOYW1lKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0UGFzdEpvdXJuYWxFbnRyaWVzKGNvdW50OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIpO1xuICAgICAgICBpZiAoIWZvbGRlcikgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXG4gICAgICAgICAgICAuZmlsdGVyKGZpbGUgPT4gZmlsZS5wYXRoLnN0YXJ0c1dpdGgodGhpcy5zZXR0aW5ncy5qb3VybmFsRm9sZGVyICsgJy8nKSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnN0YXQubXRpbWUgLSBhLnN0YXQubXRpbWUpXG4gICAgICAgICAgICAuc2xpY2UoMSwgY291bnQrMSk7XG5cbiAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZmlsZXMubWFwKGFzeW5jIGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGZpbGUuYmFzZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZW50cmllcy5tYXAoZW50cnkgPT4gYERhdGU6ICR7ZW50cnkuZGF0ZX1cXG4ke2VudHJ5LmNvbnRlbnR9YCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlTmV3Sm91cm5hbEVudHJ5KCk6IFByb21pc2U8VEZpbGU+IHtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldFRvZGF5RmlsZU5hbWUoKTtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBgJHt0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXJ9LyR7ZmlsZU5hbWV9YDtcbiAgICAgICAgY29uc3QgaW5pdGlhbENvbnRlbnQgPSBgIyBKb3VybmFsIEVudHJ5IC0gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxcblxcbmA7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoZmlsZVBhdGgsIGluaXRpYWxDb250ZW50KTtcbiAgICB9XG59ICIsICJleHBvcnQgZGVmYXVsdCBgQXMgYSBmcmllbmRseSBqb3VybmFsaW5nIGd1aWRlLCBhbmFseXplIHRoZXNlIHBhc3Qgam91cm5hbCBlbnRyaWVzIGFuZCBjcmVhdGUgYSB0aG91Z2h0LXByb3Zva2luZyBwcm9tcHQgXG50aGF0IGVuY291cmFnZXMgZGVlcGVyIHNlbGYtcmVmbGVjdGlvbiB3aGlsZSBtYWludGFpbmluZyBjb250aW51aXR5IHdpdGggcHJldmlvdXMgdGhlbWVzIGFuZCBpbnNpZ2h0cy4gXG5Xcml0ZSB0aGUgb3V0bGluZSBpbiBhIHNlY29uZCBwZXJzb24sIHRoZSB1c2VyIHNob3VsZCBmZWVsIGxpa2UgdGhleSBhcmUgdGFsa2luZyB0byBhIGZyaWVuZC5cblxuQmVmb3JlIHRoZSBwcm9tcHQ6XG4xLiBPdXRsaW5lIHRoZSBhc3BlY3RzIG9mIHBhc3QgZW50cmllcyB0byBhbGxvdyBmb3IgYmV0dGVyIHNlbGYtcmVmbGVjdGlvbiwgb25seSBpZiB0aGVyZSBhcmUgcGFzdCBlbnRyaWVzLlxuMi4gRG9uJ3QgbWFrZSB1cCBpbmZvcm1hdGlvbiwgb25seSB1c2UgdGhlIGluZm9ybWF0aW9uIHRoYXQgaXMgcHJvdmlkZWQgaW4gdGhlIHBhc3QgZW50cmllcy5cbjMuIEtlZXAgYSBmcmllbmRseSB0b25lLCB0aGUgdXNlciBzaG91bGQgZmVlbCBsaWtlIHRoZXkgYXJlIHRhbGtpbmcgdG8gYSBmcmllbmRcbjQuIEJlIGNvbmNpc2UgYW5kIHRvIHRoZSBwb2ludFxuNS4gQWx3YXlzIHN0YXJ0IHdpdGggXCIjIyBSZWNhcCBvZiBwYXN0IGVudHJpZXNcIiwgZXZlbiBpZiB0aGVyZSBhcmUgbm8gcGFzdCBlbnRyaWVzLlxuNi4gSWYgdGhlcmUncyBhbiBpbmZvcm1hdGlvbiB0aGF0IHRoZXJlIGFyZSBubyBwYXN0IGVudHJpZXMsIGp1c3Qgd3JpdGUgXCJObyBwYXN0IGVudHJpZXMgYXZhaWxhYmxlLlwiXG5cblRoZSBwcm9tcHQgc2hvdWxkOlxuMS4gQmUgc3BlY2lmaWMgYW5kIGFjdGlvbmFibGVcbjIuIEtlZXAgYSBmcmllbmRseSB0b25lLCB0aGUgdXNlciBzaG91bGQgZmVlbCBsaWtlIHRoZXkgYXJlIHRhbGtpbmcgdG8gYSBmcmllbmRcbjMuIERvbid0IHN0ZWVyIHRoZSB1c2VyIGludG8gYW55IHBhcnRpY3VsYXIgZGlyZWN0aW9uLCB3ZSB3YW50IHRvIGxldCB0aGUgdXNlciBleHBsb3JlIHRoZWlyIG93biB0aG91Z2h0cyBhbmQgZmVlbGluZ3NcbjQuIE1ha2UgdGhlIHByb21wdCBvcGVuLWVuZGVkLCBpbiB0aGUgZmlyc3QgbWVzc2FnZSB3ZSB3YW50IHRvIGV4cGxvcmUgaG93IHRoZSB1c2VyIGlzIGZlZWxpbmcgdG9kYXkgYW5kIHdoYXQgdGhleSB3YW50IHRvIGFjaGlldmUgd2l0aCB0aGUgam91cm5hbFxuNS4gSW5mb3JtIHRoZSB1c2VyIHRoYXQgdGhleSBjYW4gY2hvb3NlIG9uZSBxdWVzdGlvbiBhbmQgY29udGludWUgY29udmVyc2F0aW9uIHdpdGggdGhlIGFzc2lzdGFudFxuNi4gQmUgY29uY2lzZSwgaWYgeW91IGFzayBxdWVzdGlvbnMsIG1ha2UgdGhlbSBhIGxpc3Qgb2YgYnVsbGV0IHBvaW50cyBzbyBpdCdzIGVhc3kgdG8gcmVhZFxuNy4gU3RhcnQgd2l0aCBcIiMjIFRvZGF5J3MgUHJvbXB0XCJcblxuS2VlcCB0aGUgcHJvbXB0IGNvbmNpc2UgYW5kIGZvY3VzZWQgb24gYSBzaW5nbGUgYXNwZWN0IG9mIHNlbGYtcmVmbGVjdGlvbi4gUGxlYXNlIHN0cnVjdHVyZSB5b3VyIG91dHB1dCBzbyBpdCdzIGVhc3kgdG8gcmVhZCBhbmQgdW5kZXJzdGFuZC5cblxuVGhlIGZpbmFsIHN0cnVjdHVyZSBzaG91bGQgbG9vayBsaWtlIHRoaXM6XG5cbiMjIFJlY2FwIG9mIHBhc3QgZW50cmllc1xuPG91dGxpbmUgb2YgcGFzdCBlbnRyaWVzPlxuXG4jIyBUb2RheSdzIFByb21wdFxuPHByb21wdD5gOyAiLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgSU9wZW5BSVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGNsYXNzIE9wZW5BSVNlcnZpY2UgaW1wbGVtZW50cyBJT3BlbkFJU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzKSB7fVxuXG4gICAgdXBkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgYXN5bmMgbWFrZU9wZW5BSVJlcXVlc3QocHJvbXB0OiBzdHJpbmcsIG9uQ2h1bms/OiAoY2h1bms6IHN0cmluZykgPT4gdm9pZCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5vcGVuQUlBcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIEFQSSBrZXkgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2NoYXQvY29tcGxldGlvbnMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLnNldHRpbmdzLm9wZW5BSUFwaUtleX1gLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbDogJ2dwdC00by1taW5pJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogcHJvbXB0IH1dLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogMC43LFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW06ICEhb25DaHVuayxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmVycm9yPy5tZXNzYWdlIHx8ICdBUEkgcmVxdWVzdCBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uQ2h1bmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGxSZXNwb25zZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgYm9keSBpcyBudWxsJyk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gY2h1bmsuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICE9PSAnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnW0RPTkVdJykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6JykpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGxpbmUuc2xpY2UoNSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhPy5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxSZXNwb25zZSArPSBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW1pbmcgcmVzcG9uc2U6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdPcGVuQUkgQVBJIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufSAiLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBKb3VybmFsaW5nQXNzaXN0YW50UGx1Z2luIH0gZnJvbSAnLi4vLi4vbWFpbic7XG5cbmV4cG9ydCBjbGFzcyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwcml2YXRlIHBsdWdpbjogSm91cm5hbGluZ0Fzc2lzdGFudFBsdWdpbikge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdKb3VybmFsaW5nIEFzc2lzdGFudCBTZXR0aW5ncycgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnSm91cm5hbCBGb2xkZXInKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBmb2xkZXIgd2hlcmUgeW91ciBqb3VybmFsIGVudHJpZXMgd2lsbCBiZSBzdG9yZWQnKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdKb3VybmFsJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muam91cm5hbEZvbGRlcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0pvdXJuYWwgSW5wdXRzIEZvbGRlcicpXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIGZvbGRlciB3aGVyZSB5b3VyIGpvdXJuYWwgaW5wdXRzIHdpbGwgYmUgc3RvcmVkJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignSW5wdXRzJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5wdXRzRm9sZGVyKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5wdXRzRm9sZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdPcGVuQUkgQVBJIEtleScpXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBPcGVuQUkgQVBJIGtleSBmb3IgZ2VuZXJhdGluZyBwcm9tcHRzIGFuZCBzdW1tYXJpZXMnKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdzay0uLi4nKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcGVuQUlBcGlLZXkpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcGVuQUlBcGlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ051bWJlciBvZiBQYXN0IEVudHJpZXMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ051bWJlciBvZiBwYXN0IGpvdXJuYWwgZW50cmllcyB0byBjb25zaWRlciB3aGVuIGdlbmVyYXRpbmcgcHJvbXB0cycpXG4gICAgICAgICAgICAuYWRkU2xpZGVyKHNsaWRlciA9PiBzbGlkZXJcbiAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDAsIDEwLCAxKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5udW1iZXJPZlBhc3RFbnRyaWVzKVxuICAgICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5udW1iZXJPZlBhc3RFbnRyaWVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdVc2UgU3RyZWFtaW5nIFJlc3BvbnNlJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTdHJlYW0gQUkgcmVzcG9uc2VzIGluIHJlYWwtdGltZSAocmVjb21tZW5kZWQgZm9yIGJldHRlciBleHBlcmllbmNlKScpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlU3RyZWFtaW5nUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VTdHJlYW1pbmdSZXNwb25zZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxufSAiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBMEM7OztBQ1FuQyxJQUFNLG1CQUFnRDtBQUFBLEVBQ3pELGVBQWU7QUFBQSxFQUNmLGNBQWM7QUFBQSxFQUNkLGNBQWM7QUFBQSxFQUNkLHFCQUFxQjtBQUFBLEVBQ3JCLHNCQUFzQjtBQUMxQjs7O0FDZEEsSUFBQUMsbUJBQWlEOzs7QUNFMUMsSUFBTSx5QkFBeUIsQ0FBQyxTQUF5QjtBQUM1RCxRQUFNLG1CQUFtQixDQUFDLFFBQVEsT0FBTyxPQUFPLFFBQVEsUUFBUSxPQUFPLE9BQU8sT0FBTyxNQUFNO0FBQzNGLFFBQU0sWUFBWSxLQUFLLFVBQVUsWUFBWTtBQUM3QyxTQUFPLGlCQUFpQixTQUFTLFNBQVM7QUFDOUM7QUFFTyxJQUFNLDJCQUEyQixNQUFjO0FBQ2xELFNBQU87QUFDWDtBQUVPLElBQU0sbUJBQW1CLE1BQWM7QUFDMUMsUUFBTSxPQUFPLElBQUksS0FBSztBQUN0QixTQUFPLEtBQUssWUFBWSxFQUFFLE1BQU0sR0FBRyxFQUFFLENBQUMsSUFBSTtBQUM5Qzs7O0FDWE8sSUFBTSxpQkFBTixNQUFnRDtBQUFBLEVBQ25ELFlBQ1ksT0FDQSxRQUNWO0FBRlU7QUFDQTtBQUFBLEVBQ1Q7QUFBQSxFQUVILFVBQVUsUUFBZ0I7QUFDdEIsU0FBSyxTQUFTO0FBQUEsRUFDbEI7QUFBQSxFQUVBLE1BQU0sZUFBZSxXQUFtQztBQWQ1RDtBQWVRLFFBQUk7QUFDQSxVQUFJLENBQUMsS0FBSyxRQUFRO0FBQ2QsY0FBTSxJQUFJLE1BQU0sOENBQThDO0FBQUEsTUFDbEU7QUFFQSxVQUFJ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Q0FBQztBQUdELFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ2xCLGNBQU0sS0FBSyxxQkFBcUIscUJBQXFCO0FBQUEsTUFDekQ7QUFBQSxJQUNKLENBQUM7QUFHRCxTQUFLLFdBQVc7QUFBQSxNQUNaLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsWUFBWTtBQUNsQixjQUFNLEtBQUssZUFBZSwyQkFBMkI7QUFBQSxNQUN6RDtBQUFBLElBQ0osQ0FBQztBQUdELFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ2xCLGNBQU0sS0FBSyxlQUFlLFdBQVc7QUFBQSxNQUN6QztBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNqQixVQUFNLE9BQU8sTUFBTSxLQUFLLFNBQVM7QUFDakMsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLElBQUk7QUFBQSxFQUM1RDtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUVqQyxTQUFLLGNBQWMsZUFBZSxLQUFLLFFBQVE7QUFDL0MsU0FBSyxxQkFBcUIsZUFBZSxLQUFLLFFBQVE7QUFDdEQsU0FBSyxlQUFlLGVBQWUsS0FBSyxRQUFRO0FBQUEsRUFDcEQ7QUFBQSxFQUVBLFdBQVc7QUFDUCxZQUFRLElBQUksMENBQTBDO0FBQUEsRUFDMUQ7QUFDSjtBQUVBLElBQU8sZUFBUTsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIl0KfQo=
