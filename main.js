/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  JournalingAssistantPlugin: () => JournalingAssistantPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  journalFolder: "Journal",
  inputsFolder: "Inputs",
  openAIApiKey: "",
  numberOfPastEntries: 3,
  useStreamingResponse: true
};

// src/services/JournalService.ts
var import_obsidian4 = require("obsidian");

// src/services/TranscriptionService.ts
var import_obsidian = require("obsidian");
var TranscriptionService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.whisperService = new WhisperService(this.app.vault, this.settings.openAIApiKey);
  }
  updateSettings(settings) {
    this.settings = settings;
    this.whisperService.setApiKey(settings.openAIApiKey);
  }
  /**
   * Checks if the file format is directly supported by Whisper API
   */
  static isSupportedFormat(file) {
    const supportedFormats = ["flac", "mp3", "mp4", "mpeg", "mpga", "m4a", "ogg", "wav", "webm"];
    const extension = file.extension.toLowerCase();
    return supportedFormats.includes(extension);
  }
  /**
   * Prepares audio file for transcription
   */
  async prepareAudioForTranscription(file) {
    const arrayBuffer = await this.app.vault.readBinary(file);
    const extension = file.extension.toLowerCase();
    const mimeTypes = {
      "flac": "audio/flac",
      "mp3": "audio/mpeg",
      "mp4": "audio/mp4",
      "mpeg": "audio/mpeg",
      "mpga": "audio/mpeg",
      "m4a": "audio/mp4",
      "ogg": "audio/ogg",
      "wav": "audio/wav",
      "webm": "audio/webm"
    };
    const mimeType = mimeTypes[extension];
    if (!mimeType) {
      throw new Error(`Unsupported MIME type for extension: ${extension}`);
    }
    return {
      blob: new Blob([arrayBuffer], { type: mimeType }),
      mimeType
    };
  }
  /**
   * Returns a RegExp pattern that matches Obsidian's embed syntax for supported audio formats
   */
  static getRecordingEmbedPattern() {
    return /!\[\[.+\.(flac|mp3|mp4|mpeg|mpga|m4a|ogg|wav|webm)\]\]/g;
  }
  async transcribeRecordings() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    if (!this.settings.openAIApiKey) {
      new import_obsidian.Notice("OpenAI API key not configured");
      return;
    }
    const editor = activeView.editor;
    const content = editor.getValue();
    const recordingPattern = TranscriptionService.getRecordingEmbedPattern();
    const recordings = content.match(recordingPattern);
    if (!recordings || recordings.length === 0) {
      new import_obsidian.Notice("No recordings found in the current note");
      return;
    }
    new import_obsidian.Notice("Starting transcription...");
    let updatedContent = content;
    let hasErrors = false;
    try {
      for (const recording of recordings) {
        const fileName = recording.slice(3, -2);
        const file = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
        if (!(file instanceof import_obsidian.TFile)) {
          new import_obsidian.Notice(`Could not find file: ${fileName}`);
          hasErrors = true;
          continue;
        }
        try {
          const transcript = await this.whisperService.transcribeFile(file);
          updatedContent = updatedContent.replace(recording, transcript);
        } catch (error) {
          new import_obsidian.Notice(`Failed to transcribe ${fileName}: ${error.message}`);
          hasErrors = true;
          continue;
        }
      }
      editor.setValue(updatedContent);
      if (hasErrors) {
        new import_obsidian.Notice("Transcription completed with some errors");
      } else {
        new import_obsidian.Notice("Transcription completed successfully");
      }
    } catch (error) {
      new import_obsidian.Notice(`Transcription failed: ${error.message}`);
      console.error("Transcription error:", error);
    }
  }
};

// src/services/WhisperService.ts
var WhisperService = class {
  constructor(vault, apiKey) {
    this.vault = vault;
    this.apiKey = apiKey;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  async transcribeFile(audioFile) {
    var _a;
    try {
      if (!this.apiKey) {
        throw new Error("OpenAI API key is required for transcription");
      }
      if (!TranscriptionService.isSupportedFormat(audioFile)) {
        throw new Error(`Unsupported audio format: ${audioFile.extension}`);
      }
      const formData = new FormData();
      const arrayBuffer = await this.vault.readBinary(audioFile);
      const blob = new Blob([arrayBuffer], { type: `audio/${audioFile.extension}` });
      formData.append("file", blob, `${audioFile.basename}.${audioFile.extension}`);
      formData.append("model", "whisper-1");
      const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: formData
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(((_a = error.error) == null ? void 0 : _a.message) || "Transcription failed");
      }
      const result = await response.json();
      return result.text;
    } catch (error) {
      console.error("Transcription error:", error);
      throw error;
    }
  }
};

// src/services/SummarizationService.ts
var import_obsidian2 = require("obsidian");

// src/prompts/summaryPrompt.ts
var summaryPrompt_default = `As a journaling assistant, analyze this journal entry and create a concise summary that:

1. Identifies the main themes and insights
2. Highlights key realizations or breakthroughs
3. Notes any action items or intentions expressed
4. Preserves the emotional tone of the entry

Focus on extracting the most meaningful elements while maintaining the personal nature of the reflection.`;

// src/services/SummarizationService.ts
var SummarizationService = class {
  constructor(openAIService) {
    this.openAIService = openAIService;
  }
  /**
   * Takes the user's journal response and returns a summary
   * @param content The content to summarize
   * @param useStreaming Whether to stream the response
   * @param onChunk Optional callback for streaming responses
   */
  async summarize(content, useStreaming = false, onChunk) {
    try {
      const prompt = `${summaryPrompt_default}

${content}`;
      return await this.openAIService.makeOpenAIRequest(
        prompt,
        useStreaming ? onChunk : void 0
      );
    } catch (error) {
      new import_obsidian2.Notice(`Error during summarization: ${error.message}`);
      throw error;
    }
  }
};

// src/services/PromptService.ts
var import_obsidian3 = require("obsidian");

// src/prompts/journalPrompt.ts
var journalPrompt_default = `As a friendly journaling guide, analyze these past journal entries and create a thought-provoking prompt 
that encourages deeper self-reflection while maintaining continuity with previous themes and insights. 
Write the outline in a second person, the user should feel like they are talking to a friend.

Before the prompt:
1. Outline the aspects of past entries to allow for better self-reflection, only if there are past entries.
2. Don't make up information, only use the information that is provided in the past entries.
3. Keep a friendly tone, the user should feel like they are talking to a friend
4. Be concise and to the point
5. Always start with "## Recap of past entries", even if there are no past entries.
6. If there's an information that there are no past entries, just write "No past entries available."

The prompt should:
1. Be specific and actionable
2. Keep a friendly tone, the user should feel like they are talking to a friend
3. Don't steer the user into any particular direction, we want to let the user explore their own thoughts and feelings
4. Make the prompt open-ended, in the first message we want to explore how the user is feeling today and what they want to achieve with the journal
5. Inform the user that they can choose one question and continue conversation with the assistant
6. Be concise, if you ask questions, make them a list of bullet points so it's easy to read
7. Start with "## Today's Prompt"

Keep the prompt concise and focused on a single aspect of self-reflection. Please structure your output so it's easy to read and understand.


The final structure should look like this:

## Recap of past entries
<outline of past entries>

## Today's Prompt
<prompt>`;

// src/services/PromptService.ts
var PromptService = class {
  constructor(openAIService) {
    this.openAIService = openAIService;
  }
  /**
   * Generates a journal prompt based on past entries
   * @param pastEntries Array of past journal entries
   * @param onChunk Optional callback for streaming responses
   */
  async generatePrompt(pastEntries, onChunk) {
    try {
      const pastEntriesText = pastEntries.length > 0 ? `Past Entries:

${pastEntries.join("\n\n---\n\n")}` : "No past entries available.";
      const prompt = `${journalPrompt_default}

${pastEntriesText}`;
      return await this.openAIService.makeOpenAIRequest(prompt, onChunk);
    } catch (error) {
      new import_obsidian3.Notice(`Error generating prompt: ${error.message}`);
      throw error;
    }
  }
};

// src/services/JournalService.ts
var JournalService = class {
  constructor(app, settings, openAIService) {
    this.app = app;
    this.settings = settings;
    this.openAIService = openAIService;
    this.whisperService = new WhisperService(this.app.vault, this.settings.openAIApiKey);
    this.summarizationService = new SummarizationService(this.openAIService);
    this.promptService = new PromptService(this.openAIService);
  }
  updateSettings(settings) {
    this.settings = settings;
    this.whisperService.setApiKey(settings.openAIApiKey);
  }
  getTodayFileName() {
    const date = new Date();
    return date.toISOString().split("T")[0] + ".md";
  }
  async ensureFolder(folderPath) {
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async getPastJournalEntries(count) {
    const folder = this.app.vault.getAbstractFileByPath(this.settings.journalFolder);
    if (!folder)
      return [];
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.journalFolder + "/")).sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, count);
    const entries = await Promise.all(
      files.map(async (file) => {
        const content = await this.app.vault.read(file);
        return {
          date: file.basename,
          content
        };
      })
    );
    return entries.map((entry) => `Date: ${entry.date}
${entry.content}`);
  }
  async openTodaysJournal() {
    try {
      await this.ensureFolder(this.settings.journalFolder);
      const fileName = this.getTodayFileName();
      const filePath = `${this.settings.journalFolder}/${fileName}`;
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        let initialContent = `# Journal Entry - ${new Date().toLocaleDateString()}

`;
        file = await this.app.vault.create(filePath, initialContent);
        try {
          const loadingNotice = new import_obsidian4.Notice("Generating journal prompt...", 0);
          const pastEntries = await this.getPastJournalEntries(this.settings.numberOfPastEntries);
          const leaf = this.app.workspace.getLeaf(false);
          await leaf.openFile(file);
          const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
          if (view) {
            if (this.settings.useStreamingResponse) {
              await this.promptService.generatePrompt(pastEntries, (chunk) => {
                const currentContent = view.editor.getValue();
                view.editor.setValue(currentContent + chunk);
              });
            } else {
              const aiPrompt = await this.promptService.generatePrompt(pastEntries);
              view.editor.setValue(view.editor.getValue() + aiPrompt);
            }
            const finalContent = view.editor.getValue();
            view.editor.setValue(finalContent + "\n\n## Your Journal Response\n\n");
          }
          loadingNotice.hide();
          new import_obsidian4.Notice("Created new journal entry for today");
        } catch (error) {
          new import_obsidian4.Notice("Error generating prompt: " + error.message);
          const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
          if (view) {
            view.editor.setValue(view.editor.getValue() + "\n\n## Your Journal Response\n\n");
          }
        }
      } else {
        const leaf = this.app.workspace.getLeaf(false);
        await leaf.openFile(file);
      }
    } catch (error) {
      new import_obsidian4.Notice("Error opening today's journal: " + error.message);
      console.error("Error opening today's journal:", error);
    }
  }
  async summarizeJournalingSession() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!activeView) {
      new import_obsidian4.Notice("Please open a note first");
      return;
    }
    if (!activeView.file) {
      new import_obsidian4.Notice("No file is currently open");
      return;
    }
    try {
      const originalContent = activeView.editor.getValue();
      const fileName = activeView.file.name;
      const inputPath = `${this.settings.inputsFolder}/${fileName}`;
      await this.ensureFolder(this.settings.inputsFolder);
      await this.app.vault.create(inputPath, originalContent);
      let processedContent = await this.processContent(originalContent);
      const responseMatch = processedContent.match(/## Your Journal Response\n\n([\s\S]*$)/);
      if (!responseMatch) {
        new import_obsidian4.Notice("Could not find journal response section");
        return;
      }
      const userResponse = responseMatch[1];
      let summary;
      if (this.settings.useStreamingResponse) {
        let streamedSummary = "";
        summary = await this.summarizationService.summarize(
          userResponse,
          true,
          (chunk) => {
            streamedSummary += chunk;
            const updatedContent2 = processedContent.replace(
              /## Your Journal Response\n\n[\s\S]*$/,
              `## Your Journal Response

${streamedSummary}`
            );
            activeView.editor.setValue(updatedContent2);
          }
        );
      } else {
        summary = await this.summarizationService.summarize(userResponse);
      }
      const updatedContent = processedContent.replace(
        /## Your Journal Response\n\n[\s\S]*$/,
        `## Your Journal Response

${summary}`
      );
      activeView.editor.setValue(updatedContent);
      new import_obsidian4.Notice("Journal session summarized");
    } catch (error) {
      new import_obsidian4.Notice(`Error: ${error.message}`);
      console.error("Summarization error:", error);
    }
  }
  async processContent(content) {
    const recordingPattern = TranscriptionService.getRecordingEmbedPattern();
    const recordings = content.match(recordingPattern);
    if (!recordings)
      return content;
    let processedContent = content;
    for (const recording of recordings) {
      const fileName = recording.slice(3, -2);
      const file = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
      if (file instanceof import_obsidian4.TFile) {
        const transcript = await this.whisperService.transcribeFile(file);
        processedContent = processedContent.replace(recording, transcript);
      }
    }
    return processedContent;
  }
};

// src/services/OpenAIService.ts
var OpenAIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async makeOpenAIRequest(prompt, onChunk) {
    var _a, _b, _c, _d;
    if (!this.settings.openAIApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.openAIApiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [{ role: "user", content: prompt }],
          temperature: 0.7,
          stream: !!onChunk
          // Enable streaming if onChunk callback is provided
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(((_a = error.error) == null ? void 0 : _a.message) || "API request failed");
      }
      if (onChunk) {
        const reader = (_b = response.body) == null ? void 0 : _b.getReader();
        const decoder = new TextDecoder();
        let fullResponse = "";
        if (!reader)
          throw new Error("Response body is null");
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          const chunk = decoder.decode(value);
          const lines = chunk.split("\n").filter((line) => line.trim() !== "");
          for (const line of lines) {
            if (line.includes("[DONE]"))
              continue;
            if (!line.startsWith("data:"))
              continue;
            try {
              const json = JSON.parse(line.slice(5));
              const content = (_d = (_c = json.choices[0]) == null ? void 0 : _c.delta) == null ? void 0 : _d.content;
              if (content) {
                fullResponse += content;
                onChunk(content);
              }
            } catch (e) {
              console.warn("Failed to parse streaming response:", e);
            }
          }
        }
        return fullResponse;
      }
      const data = await response.json();
      return data.choices[0].message.content;
    } catch (error) {
      console.error("OpenAI API error:", error);
      throw error;
    }
  }
};

// src/settings/SettingTab.ts
var import_obsidian5 = require("obsidian");
var JournalingAssistantSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Journaling Assistant Settings" });
    new import_obsidian5.Setting(containerEl).setName("Journal Folder").setDesc("The folder where your journal entries will be stored").addText((text) => text.setPlaceholder("Journal").setValue(this.plugin.settings.journalFolder).onChange(async (value) => {
      this.plugin.settings.journalFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Journal Inputs Folder").setDesc("The folder where your journal inputs will be stored").addText((text) => text.setPlaceholder("Inputs").setValue(this.plugin.settings.inputsFolder).onChange(async (value) => {
      this.plugin.settings.inputsFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating prompts and summaries").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
      this.plugin.settings.openAIApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Number of Past Entries").setDesc("Number of past journal entries to consider when generating prompts").addSlider((slider) => slider.setLimits(0, 10, 1).setValue(this.plugin.settings.numberOfPastEntries).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.numberOfPastEntries = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Use Streaming Response").setDesc("Stream AI responses in real-time (recommended for better experience)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useStreamingResponse).onChange(async (value) => {
      this.plugin.settings.useStreamingResponse = value;
      await this.plugin.saveSettings();
    }));
  }
};

// main.ts
var JournalingAssistantPlugin = class extends import_obsidian6.Plugin {
  async onload() {
    await this.loadSettings();
    this.openAIService = new OpenAIService(this.settings);
    this.journalService = new JournalService(this.app, this.settings, this.openAIService);
    this.transcriptionService = new TranscriptionService(this.app, this.settings);
    this.addSettingTab(new JournalingAssistantSettingTab(this.app, this));
    this.addRibbonIcon("bot", "Journal with AI", async () => {
      await this.journalService.openTodaysJournal();
    });
    this.addCommands();
  }
  addCommands() {
    this.addCommand({
      id: "open-todays-journal",
      name: "Open Today's Journal",
      callback: async () => {
        await this.journalService.openTodaysJournal();
      }
    });
    this.addCommand({
      id: "transcribe-recordings",
      name: "Transcribe Recordings",
      callback: async () => {
        await this.transcriptionService.transcribeRecordings();
      }
    });
    this.addCommand({
      id: "summarize-journal",
      name: "Summarize Journaling Session",
      callback: async () => {
        await this.journalService.summarizeJournalingSession();
      }
    });
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    console.log(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.openAIService = new OpenAIService(this.settings);
    this.transcriptionService.updateSettings(this.settings);
    this.journalService.updateSettings(this.settings);
  }
  onunload() {
    console.log("Unloading Journaling Assistant Plugin...");
  }
};
var main_default = JournalingAssistantPlugin;
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL3NlcnZpY2VzL0pvdXJuYWxTZXJ2aWNlLnRzIiwgInNyYy9zZXJ2aWNlcy9UcmFuc2NyaXB0aW9uU2VydmljZS50cyIsICJzcmMvc2VydmljZXMvV2hpc3BlclNlcnZpY2UudHMiLCAic3JjL3NlcnZpY2VzL1N1bW1hcml6YXRpb25TZXJ2aWNlLnRzIiwgInNyYy9wcm9tcHRzL3N1bW1hcnlQcm9tcHQudHMiLCAic3JjL3NlcnZpY2VzL1Byb21wdFNlcnZpY2UudHMiLCAic3JjL3Byb21wdHMvam91cm5hbFByb21wdC50cyIsICJzcmMvc2VydmljZXMvT3BlbkFJU2VydmljZS50cyIsICJzcmMvc2V0dGluZ3MvU2V0dGluZ1RhYi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIE1hcmtkb3duVmlldywgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi9zcmMvdHlwZXMnO1xuaW1wb3J0IHsgSm91cm5hbFNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9Kb3VybmFsU2VydmljZSc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvT3BlbkFJU2VydmljZSc7XG5pbXBvcnQgeyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ1RhYiB9IGZyb20gJy4vc3JjL3NldHRpbmdzL1NldHRpbmdUYWInO1xuaW1wb3J0IHsgVHJhbnNjcmlwdGlvblNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9UcmFuc2NyaXB0aW9uU2VydmljZSc7XG5cbmV4cG9ydCBjbGFzcyBKb3VybmFsaW5nQXNzaXN0YW50UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzO1xuICAgIHByaXZhdGUgam91cm5hbFNlcnZpY2U6IEpvdXJuYWxTZXJ2aWNlO1xuICAgIHByaXZhdGUgb3BlbkFJU2VydmljZTogT3BlbkFJU2VydmljZTtcbiAgICBwcml2YXRlIHRyYW5zY3JpcHRpb25TZXJ2aWNlOiBUcmFuc2NyaXB0aW9uU2VydmljZTtcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMub3BlbkFJU2VydmljZSA9IG5ldyBPcGVuQUlTZXJ2aWNlKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmpvdXJuYWxTZXJ2aWNlID0gbmV3IEpvdXJuYWxTZXJ2aWNlKHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzLCB0aGlzLm9wZW5BSVNlcnZpY2UpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpcHRpb25TZXJ2aWNlID0gbmV3IFRyYW5zY3JpcHRpb25TZXJ2aWNlKHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgdGFiXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgcmliYm9uIGljb25cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKCdib3QnLCAnSm91cm5hbCB3aXRoIEFJJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5qb3VybmFsU2VydmljZS5vcGVuVG9kYXlzSm91cm5hbCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmRzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnb3Blbi10b2RheXMtam91cm5hbCcsXG4gICAgICAgICAgICBuYW1lOiAnT3BlbiBUb2RheVxcJ3MgSm91cm5hbCcsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuam91cm5hbFNlcnZpY2Uub3BlblRvZGF5c0pvdXJuYWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ3RyYW5zY3JpYmUtcmVjb3JkaW5ncycsXG4gICAgICAgICAgICBuYW1lOiAnVHJhbnNjcmliZSBSZWNvcmRpbmdzJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc2NyaXB0aW9uU2VydmljZS50cmFuc2NyaWJlUmVjb3JkaW5ncygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnc3VtbWFyaXplLWpvdXJuYWwnLFxuICAgICAgICAgICAgbmFtZTogJ1N1bW1hcml6ZSBKb3VybmFsaW5nIFNlc3Npb24nLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmpvdXJuYWxTZXJ2aWNlLnN1bW1hcml6ZUpvdXJuYWxpbmdTZXNzaW9uKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmxvYWREYXRhKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBkYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAvLyBVcGRhdGUgc2VydmljZXMgd2l0aCBuZXcgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5vcGVuQUlTZXJ2aWNlID0gbmV3IE9wZW5BSVNlcnZpY2UodGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudHJhbnNjcmlwdGlvblNlcnZpY2UudXBkYXRlU2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuam91cm5hbFNlcnZpY2UudXBkYXRlU2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5sb2FkaW5nIEpvdXJuYWxpbmcgQXNzaXN0YW50IFBsdWdpbi4uLlwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpvdXJuYWxpbmdBc3Npc3RhbnRQbHVnaW47XG4iLCAiZXhwb3J0IGludGVyZmFjZSBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3Mge1xuICAgIGpvdXJuYWxGb2xkZXI6IHN0cmluZztcbiAgICBpbnB1dHNGb2xkZXI6IHN0cmluZztcbiAgICBvcGVuQUlBcGlLZXk6IHN0cmluZztcbiAgICBudW1iZXJPZlBhc3RFbnRyaWVzOiBudW1iZXI7XG4gICAgdXNlU3RyZWFtaW5nUmVzcG9uc2U6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MgPSB7XG4gICAgam91cm5hbEZvbGRlcjogJ0pvdXJuYWwnLFxuICAgIGlucHV0c0ZvbGRlcjogJ0lucHV0cycsXG4gICAgb3BlbkFJQXBpS2V5OiAnJyxcbiAgICBudW1iZXJPZlBhc3RFbnRyaWVzOiAzLFxuICAgIHVzZVN0cmVhbWluZ1Jlc3BvbnNlOiB0cnVlLFxufTsgIiwgImltcG9ydCB7IEFwcCwgVEZpbGUsIE5vdGljZSwgTWFya2Rvd25WaWV3LCBWaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4vT3BlbkFJU2VydmljZSc7XG5pbXBvcnQgeyBXaGlzcGVyU2VydmljZSB9IGZyb20gJy4vV2hpc3BlclNlcnZpY2UnO1xuaW1wb3J0IHsgVHJhbnNjcmlwdGlvblNlcnZpY2UgfSBmcm9tICcuL1RyYW5zY3JpcHRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFN1bW1hcml6YXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9TdW1tYXJpemF0aW9uU2VydmljZSc7XG5pbXBvcnQgeyBQcm9tcHRTZXJ2aWNlIH0gZnJvbSAnLi9Qcm9tcHRTZXJ2aWNlJztcblxuZXhwb3J0IGNsYXNzIEpvdXJuYWxTZXJ2aWNlIHtcbiAgICBwcml2YXRlIHdoaXNwZXJTZXJ2aWNlOiBXaGlzcGVyU2VydmljZTtcbiAgICBwcml2YXRlIHN1bW1hcml6YXRpb25TZXJ2aWNlOiBTdW1tYXJpemF0aW9uU2VydmljZTtcbiAgICBwcml2YXRlIHByb21wdFNlcnZpY2U6IFByb21wdFNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBhcHA6IEFwcCxcbiAgICAgICAgcHJpdmF0ZSBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzLFxuICAgICAgICBwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2VcbiAgICApIHtcbiAgICAgICAgdGhpcy53aGlzcGVyU2VydmljZSA9IG5ldyBXaGlzcGVyU2VydmljZSh0aGlzLmFwcC52YXVsdCwgdGhpcy5zZXR0aW5ncy5vcGVuQUlBcGlLZXkpO1xuICAgICAgICB0aGlzLnN1bW1hcml6YXRpb25TZXJ2aWNlID0gbmV3IFN1bW1hcml6YXRpb25TZXJ2aWNlKHRoaXMub3BlbkFJU2VydmljZSk7XG4gICAgICAgIHRoaXMucHJvbXB0U2VydmljZSA9IG5ldyBQcm9tcHRTZXJ2aWNlKHRoaXMub3BlbkFJU2VydmljZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2V0dGluZ3Moc2V0dGluZ3M6IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMud2hpc3BlclNlcnZpY2Uuc2V0QXBpS2V5KHNldHRpbmdzLm9wZW5BSUFwaUtleSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb2RheUZpbGVOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gKyAnLm1kJzsgLy8gRm9ybWF0OiBZWVlZLU1NLURELm1kXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBlbnN1cmVGb2xkZXIoZm9sZGVyUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZvbGRlclBhdGgpKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKGZvbGRlclBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRQYXN0Sm91cm5hbEVudHJpZXMoY291bnQ6IG51bWJlcik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc2V0dGluZ3Muam91cm5hbEZvbGRlcik7XG4gICAgICAgIGlmICghZm9sZGVyKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aCh0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIgKyAnLycpKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc3RhdC5tdGltZSAtIGEuc3RhdC5tdGltZSlcbiAgICAgICAgICAgIC5zbGljZSgwLCBjb3VudCk7XG5cbiAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZmlsZXMubWFwKGFzeW5jIGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGZpbGUuYmFzZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZW50cmllcy5tYXAoZW50cnkgPT4gYERhdGU6ICR7ZW50cnkuZGF0ZX1cXG4ke2VudHJ5LmNvbnRlbnR9YCk7XG4gICAgfVxuXG4gICAgYXN5bmMgb3BlblRvZGF5c0pvdXJuYWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUZvbGRlcih0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIpO1xuXG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZ2V0VG9kYXlGaWxlTmFtZSgpO1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBgJHt0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXJ9LyR7ZmlsZU5hbWV9YDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbENvbnRlbnQgPSBgIyBKb3VybmFsIEVudHJ5IC0gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgZmlsZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgaW5pdGlhbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRpbmdOb3RpY2UgPSBuZXcgTm90aWNlKCdHZW5lcmF0aW5nIGpvdXJuYWwgcHJvbXB0Li4uJywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3RFbnRyaWVzID0gYXdhaXQgdGhpcy5nZXRQYXN0Sm91cm5hbEVudHJpZXModGhpcy5zZXR0aW5ncy5udW1iZXJPZlBhc3RFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZmlsZSB3aXRoIGluaXRpYWwgY29udGVudCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUgYXMgVEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy51c2VTdHJlYW1pbmdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmVhbSB0aGUgQUkgcmVzcG9uc2UgZGlyZWN0bHkgaW50byB0aGUgZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9tcHRTZXJ2aWNlLmdlbmVyYXRlUHJvbXB0KHBhc3RFbnRyaWVzLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRlbnQgPSB2aWV3LmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmVkaXRvci5zZXRWYWx1ZShjdXJyZW50Q29udGVudCArIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb21wbGV0ZSByZXNwb25zZSBhbmQgdXBkYXRlIHRoZSBlZGl0b3Igb25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFpUHJvbXB0ID0gYXdhaXQgdGhpcy5wcm9tcHRTZXJ2aWNlLmdlbmVyYXRlUHJvbXB0KHBhc3RFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmVkaXRvci5zZXRWYWx1ZSh2aWV3LmVkaXRvci5nZXRWYWx1ZSgpICsgYWlQcm9tcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJlc3BvbnNlIHNlY3Rpb24gYWZ0ZXIgdGhlIHByb21wdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxDb250ZW50ID0gdmlldy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZWRpdG9yLnNldFZhbHVlKGZpbmFsQ29udGVudCArICdcXG5cXG4jIyBZb3VyIEpvdXJuYWwgUmVzcG9uc2VcXG5cXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ05vdGljZS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0NyZWF0ZWQgbmV3IGpvdXJuYWwgZW50cnkgZm9yIHRvZGF5Jyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3IgZ2VuZXJhdGluZyBwcm9tcHQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGVtcHR5IHJlc3BvbnNlIHNlY3Rpb24gaWYgcHJvbXB0IGdlbmVyYXRpb24gZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmVkaXRvci5zZXRWYWx1ZSh2aWV3LmVkaXRvci5nZXRWYWx1ZSgpICsgJ1xcblxcbiMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxlYWYub3BlbkZpbGUoZmlsZSBhcyBURmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIG9wZW5pbmcgdG9kYXlcXCdzIGpvdXJuYWw6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9wZW5pbmcgdG9kYXlcXCdzIGpvdXJuYWw6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgc3VtbWFyaXplSm91cm5hbGluZ1Nlc3Npb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBpZiAoIWFjdGl2ZVZpZXcpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBvcGVuIGEgbm90ZSBmaXJzdCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhY3RpdmVWaWV3LmZpbGUpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIGZpbGUgaXMgY3VycmVudGx5IG9wZW4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIGNvbnRlbnQgdG8gaW5wdXRzIGZvbGRlclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDb250ZW50ID0gYWN0aXZlVmlldy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYWN0aXZlVmlldy5maWxlLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFBhdGggPSBgJHt0aGlzLnNldHRpbmdzLmlucHV0c0ZvbGRlcn0vJHtmaWxlTmFtZX1gO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUZvbGRlcih0aGlzLnNldHRpbmdzLmlucHV0c0ZvbGRlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoaW5wdXRQYXRoLCBvcmlnaW5hbENvbnRlbnQpO1xuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGNvbnRlbnQgKHRyYW5zY3JpYmUgcmVjb3JkaW5ncyBpZiBhbnkpXG4gICAgICAgICAgICBsZXQgcHJvY2Vzc2VkQ29udGVudCA9IGF3YWl0IHRoaXMucHJvY2Vzc0NvbnRlbnQob3JpZ2luYWxDb250ZW50KTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB1c2VyJ3MgcmVzcG9uc2Ugc2VjdGlvblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VNYXRjaCA9IHByb2Nlc3NlZENvbnRlbnQubWF0Y2goLyMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbihbXFxzXFxTXSokKS8pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnQ291bGQgbm90IGZpbmQgam91cm5hbCByZXNwb25zZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB1c2VyUmVzcG9uc2UgPSByZXNwb25zZU1hdGNoWzFdO1xuICAgICAgICAgICAgbGV0IHN1bW1hcnk6IHN0cmluZztcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudXNlU3RyZWFtaW5nUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gc3RvcmUgdGhlIHN0cmVhbWVkIHN1bW1hcnlcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtZWRTdW1tYXJ5ID0gJyc7XG4gICAgICAgICAgICAgICAgc3VtbWFyeSA9IGF3YWl0IHRoaXMuc3VtbWFyaXphdGlvblNlcnZpY2Uuc3VtbWFyaXplKFxuICAgICAgICAgICAgICAgICAgICB1c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtZWRTdW1tYXJ5ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlZGl0b3IgaW4gcmVhbC10aW1lIHdpdGggdGhlIHBhcnRpYWwgc3VtbWFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZENvbnRlbnQgPSBwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbltcXHNcXFNdKiQvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAjIyBZb3VyIEpvdXJuYWwgUmVzcG9uc2VcXG5cXG4ke3N0cmVhbWVkU3VtbWFyeX1gXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVmlldy5lZGl0b3Iuc2V0VmFsdWUodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb21wbGV0ZSBzdW1tYXJ5IGF0IG9uY2VcbiAgICAgICAgICAgICAgICBzdW1tYXJ5ID0gYXdhaXQgdGhpcy5zdW1tYXJpemF0aW9uU2VydmljZS5zdW1tYXJpemUodXNlclJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBub3RlIHdpdGggdGhlIGZpbmFsIHN1bW1hcnlcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb250ZW50ID0gcHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8jIyBZb3VyIEpvdXJuYWwgUmVzcG9uc2VcXG5cXG5bXFxzXFxTXSokLyxcbiAgICAgICAgICAgICAgICBgIyMgWW91ciBKb3VybmFsIFJlc3BvbnNlXFxuXFxuJHtzdW1tYXJ5fWBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGFjdGl2ZVZpZXcuZWRpdG9yLnNldFZhbHVlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0pvdXJuYWwgc2Vzc2lvbiBzdW1tYXJpemVkJyk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTdW1tYXJpemF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0NvbnRlbnQoY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcmVjb3JkaW5nUGF0dGVybiA9IFRyYW5zY3JpcHRpb25TZXJ2aWNlLmdldFJlY29yZGluZ0VtYmVkUGF0dGVybigpO1xuICAgICAgICBjb25zdCByZWNvcmRpbmdzID0gY29udGVudC5tYXRjaChyZWNvcmRpbmdQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoIXJlY29yZGluZ3MpIHJldHVybiBjb250ZW50O1xuXG4gICAgICAgIGxldCBwcm9jZXNzZWRDb250ZW50ID0gY29udGVudDtcblxuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZGluZyBvZiByZWNvcmRpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHJlY29yZGluZy5zbGljZSgzLCAtMik7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChmaWxlTmFtZSwgXCJcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gYXdhaXQgdGhpcy53aGlzcGVyU2VydmljZS50cmFuc2NyaWJlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRDb250ZW50ID0gcHJvY2Vzc2VkQ29udGVudC5yZXBsYWNlKHJlY29yZGluZywgdHJhbnNjcmlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkQ29udGVudDtcbiAgICB9XG59ICIsICJpbXBvcnQgeyBOb3RpY2UsIE1hcmtkb3duVmlldywgVEZpbGUsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgV2hpc3BlclNlcnZpY2UgfSBmcm9tICcuL1doaXNwZXJTZXJ2aWNlJztcbmltcG9ydCB0eXBlIHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHR5cGUgeyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2NyaXB0aW9uU2VydmljZSB7XG4gICAgcHJpdmF0ZSB3aGlzcGVyU2VydmljZTogV2hpc3BlclNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBhcHA6IEFwcCxcbiAgICAgICAgcHJpdmF0ZSBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzXG4gICAgKSB7XG4gICAgICAgIHRoaXMud2hpc3BlclNlcnZpY2UgPSBuZXcgV2hpc3BlclNlcnZpY2UodGhpcy5hcHAudmF1bHQsIHRoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5KTtcbiAgICB9XG5cbiAgICB1cGRhdGVTZXR0aW5ncyhzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy53aGlzcGVyU2VydmljZS5zZXRBcGlLZXkoc2V0dGluZ3Mub3BlbkFJQXBpS2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGZpbGUgZm9ybWF0IGlzIGRpcmVjdGx5IHN1cHBvcnRlZCBieSBXaGlzcGVyIEFQSVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNTdXBwb3J0ZWRGb3JtYXQoZmlsZTogVEZpbGUpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkRm9ybWF0cyA9IFsnZmxhYycsICdtcDMnLCAnbXA0JywgJ21wZWcnLCAnbXBnYScsICdtNGEnLCAnb2dnJywgJ3dhdicsICd3ZWJtJ107XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGZpbGUuZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRGb3JtYXRzLmluY2x1ZGVzKGV4dGVuc2lvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYXVkaW8gZmlsZSBmb3IgdHJhbnNjcmlwdGlvblxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgcHJlcGFyZUF1ZGlvRm9yVHJhbnNjcmlwdGlvbihmaWxlOiBURmlsZSk6IFByb21pc2U8eyBibG9iOiBCbG9iOyBtaW1lVHlwZTogc3RyaW5nIH0+IHtcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkQmluYXJ5KGZpbGUpO1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBmaWxlLmV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbWltZVR5cGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgICAgICAgJ2ZsYWMnOiAnYXVkaW8vZmxhYycsXG4gICAgICAgICAgICAnbXAzJzogJ2F1ZGlvL21wZWcnLFxuICAgICAgICAgICAgJ21wNCc6ICdhdWRpby9tcDQnLFxuICAgICAgICAgICAgJ21wZWcnOiAnYXVkaW8vbXBlZycsXG4gICAgICAgICAgICAnbXBnYSc6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgICAgICdtNGEnOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgICAgICdvZ2cnOiAnYXVkaW8vb2dnJyxcbiAgICAgICAgICAgICd3YXYnOiAnYXVkaW8vd2F2JyxcbiAgICAgICAgICAgICd3ZWJtJzogJ2F1ZGlvL3dlYm0nXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBtaW1lVHlwZXNbZXh0ZW5zaW9uXTtcbiAgICAgICAgaWYgKCFtaW1lVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBNSU1FIHR5cGUgZm9yIGV4dGVuc2lvbjogJHtleHRlbnNpb259YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwgeyB0eXBlOiBtaW1lVHlwZSB9KSxcbiAgICAgICAgICAgIG1pbWVUeXBlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFJlZ0V4cCBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBPYnNpZGlhbidzIGVtYmVkIHN5bnRheCBmb3Igc3VwcG9ydGVkIGF1ZGlvIGZvcm1hdHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVjb3JkaW5nRW1iZWRQYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiAvIVxcW1xcWy4rXFwuKGZsYWN8bXAzfG1wNHxtcGVnfG1wZ2F8bTRhfG9nZ3x3YXZ8d2VibSlcXF1cXF0vZztcbiAgICB9XG5cbiAgICBhc3luYyB0cmFuc2NyaWJlUmVjb3JkaW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGlmICghYWN0aXZlVmlldykge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBub3RlIGZpcnN0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVjb3JkaW5nUGF0dGVybiA9IFRyYW5zY3JpcHRpb25TZXJ2aWNlLmdldFJlY29yZGluZ0VtYmVkUGF0dGVybigpO1xuICAgICAgICBjb25zdCByZWNvcmRpbmdzID0gY29udGVudC5tYXRjaChyZWNvcmRpbmdQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoIXJlY29yZGluZ3MgfHwgcmVjb3JkaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIHJlY29yZGluZ3MgZm91bmQgaW4gdGhlIGN1cnJlbnQgbm90ZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IE5vdGljZSgnU3RhcnRpbmcgdHJhbnNjcmlwdGlvbi4uLicpO1xuXG4gICAgICAgIGxldCB1cGRhdGVkQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGxldCBoYXNFcnJvcnMgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmRpbmcgb2YgcmVjb3JkaW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVjb3JkaW5nLnNsaWNlKDMsIC0yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChmaWxlTmFtZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3VsZCBub3QgZmluZCBmaWxlOiAke2ZpbGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gYXdhaXQgdGhpcy53aGlzcGVyU2VydmljZS50cmFuc2NyaWJlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSB1cGRhdGVkQ29udGVudC5yZXBsYWNlKHJlY29yZGluZywgdHJhbnNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIHRyYW5zY3JpYmUgJHtmaWxlTmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3Iuc2V0VmFsdWUodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnVHJhbnNjcmlwdGlvbiBjb21wbGV0ZWQgd2l0aCBzb21lIGVycm9ycycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdUcmFuc2NyaXB0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRyYW5zY3JpcHRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUcmFuc2NyaXB0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn0gIiwgImltcG9ydCB7IFRGaWxlLCBWYXVsdCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IFRyYW5zY3JpcHRpb25TZXJ2aWNlIH0gZnJvbSAnLi9UcmFuc2NyaXB0aW9uU2VydmljZSc7XG5cbmV4cG9ydCBjbGFzcyBXaGlzcGVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgdmF1bHQ6IFZhdWx0LFxuICAgICAgICBwcml2YXRlIGFwaUtleTogc3RyaW5nXG4gICAgKSB7fVxuXG4gICAgc2V0QXBpS2V5KGFwaUtleTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIH1cblxuICAgIGFzeW5jIHRyYW5zY3JpYmVGaWxlKGF1ZGlvRmlsZTogVEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIEFQSSBrZXkgaXMgcmVxdWlyZWQgZm9yIHRyYW5zY3JpcHRpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFUcmFuc2NyaXB0aW9uU2VydmljZS5pc1N1cHBvcnRlZEZvcm1hdChhdWRpb0ZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhdWRpbyBmb3JtYXQ6ICR7YXVkaW9GaWxlLmV4dGVuc2lvbn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkQmluYXJ5KGF1ZGlvRmlsZSk7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwgeyB0eXBlOiBgYXVkaW8vJHthdWRpb0ZpbGUuZXh0ZW5zaW9ufWAgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCBgJHthdWRpb0ZpbGUuYmFzZW5hbWV9LiR7YXVkaW9GaWxlLmV4dGVuc2lvbn1gKTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnbW9kZWwnLCAnd2hpc3Blci0xJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmVycm9yPy5tZXNzYWdlIHx8ICdUcmFuc2NyaXB0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUcmFuc2NyaXB0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufSAiLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4vT3BlbkFJU2VydmljZSc7XG5pbXBvcnQgc3VtbWFyeVByb21wdCBmcm9tICcuLi9wcm9tcHRzL3N1bW1hcnlQcm9tcHQnO1xuXG5leHBvcnQgY2xhc3MgU3VtbWFyaXphdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgb3BlbkFJU2VydmljZTogT3BlbkFJU2VydmljZSkge31cblxuICAgIC8qKlxuICAgICAqIFRha2VzIHRoZSB1c2VyJ3Mgam91cm5hbCByZXNwb25zZSBhbmQgcmV0dXJucyBhIHN1bW1hcnlcbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCB0byBzdW1tYXJpemVcbiAgICAgKiBAcGFyYW0gdXNlU3RyZWFtaW5nIFdoZXRoZXIgdG8gc3RyZWFtIHRoZSByZXNwb25zZVxuICAgICAqIEBwYXJhbSBvbkNodW5rIE9wdGlvbmFsIGNhbGxiYWNrIGZvciBzdHJlYW1pbmcgcmVzcG9uc2VzXG4gICAgICovXG4gICAgYXN5bmMgc3VtbWFyaXplKFxuICAgICAgICBjb250ZW50OiBzdHJpbmcsIFxuICAgICAgICB1c2VTdHJlYW1pbmc6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgb25DaHVuaz86IChjaHVuazogc3RyaW5nKSA9PiB2b2lkXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IGAke3N1bW1hcnlQcm9tcHR9XFxuXFxuJHtjb250ZW50fWA7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vcGVuQUlTZXJ2aWNlLm1ha2VPcGVuQUlSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIHByb21wdCwgXG4gICAgICAgICAgICAgICAgdXNlU3RyZWFtaW5nID8gb25DaHVuayA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3IgZHVyaW5nIHN1bW1hcml6YXRpb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufSAiLCAiLyoqXG4gKiBQcm9tcHQgZm9yIHN1bW1hcml6aW5nIGpvdXJuYWwgZW50cmllc1xuICogRXh0cmFjdHMga2V5IGluc2lnaHRzLCBwYXR0ZXJucywgYW5kIG1lYW5pbmdmdWwgcmVmbGVjdGlvbnNcbiAqIGZyb20gdGhlIHVzZXIncyBqb3VybmFsaW5nIHNlc3Npb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGBBcyBhIGpvdXJuYWxpbmcgYXNzaXN0YW50LCBhbmFseXplIHRoaXMgam91cm5hbCBlbnRyeSBhbmQgY3JlYXRlIGEgY29uY2lzZSBzdW1tYXJ5IHRoYXQ6XG5cbjEuIElkZW50aWZpZXMgdGhlIG1haW4gdGhlbWVzIGFuZCBpbnNpZ2h0c1xuMi4gSGlnaGxpZ2h0cyBrZXkgcmVhbGl6YXRpb25zIG9yIGJyZWFrdGhyb3VnaHNcbjMuIE5vdGVzIGFueSBhY3Rpb24gaXRlbXMgb3IgaW50ZW50aW9ucyBleHByZXNzZWRcbjQuIFByZXNlcnZlcyB0aGUgZW1vdGlvbmFsIHRvbmUgb2YgdGhlIGVudHJ5XG5cbkZvY3VzIG9uIGV4dHJhY3RpbmcgdGhlIG1vc3QgbWVhbmluZ2Z1bCBlbGVtZW50cyB3aGlsZSBtYWludGFpbmluZyB0aGUgcGVyc29uYWwgbmF0dXJlIG9mIHRoZSByZWZsZWN0aW9uLmA7ICIsICJpbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBqb3VybmFsUHJvbXB0IGZyb20gJy4uL3Byb21wdHMvam91cm5hbFByb21wdCc7XG5cbmV4cG9ydCBjbGFzcyBQcm9tcHRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2UpIHt9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBqb3VybmFsIHByb21wdCBiYXNlZCBvbiBwYXN0IGVudHJpZXNcbiAgICAgKiBAcGFyYW0gcGFzdEVudHJpZXMgQXJyYXkgb2YgcGFzdCBqb3VybmFsIGVudHJpZXNcbiAgICAgKiBAcGFyYW0gb25DaHVuayBPcHRpb25hbCBjYWxsYmFjayBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlc1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlUHJvbXB0KHBhc3RFbnRyaWVzOiBzdHJpbmdbXSwgb25DaHVuaz86IChjaHVuazogc3RyaW5nKSA9PiB2b2lkKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhc3RFbnRyaWVzVGV4dCA9IHBhc3RFbnRyaWVzLmxlbmd0aCA+IDAgXG4gICAgICAgICAgICAgICAgPyBgUGFzdCBFbnRyaWVzOlxcblxcbiR7cGFzdEVudHJpZXMuam9pbignXFxuXFxuLS0tXFxuXFxuJyl9YFxuICAgICAgICAgICAgICAgIDogJ05vIHBhc3QgZW50cmllcyBhdmFpbGFibGUuJztcblxuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gYCR7am91cm5hbFByb21wdH1cXG5cXG4ke3Bhc3RFbnRyaWVzVGV4dH1gO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMub3BlbkFJU2VydmljZS5tYWtlT3BlbkFJUmVxdWVzdChwcm9tcHQsIG9uQ2h1bmspO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBFcnJvciBnZW5lcmF0aW5nIHByb21wdDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59ICIsICIvKipcbiAqIFByb21wdCBmb3IgZ2VuZXJhdGluZyBkYWlseSBqb3VybmFsaW5nIHByb21wdHNcbiAqIFRha2VzIGludG8gYWNjb3VudCBwYXN0IGpvdXJuYWwgZW50cmllcyB0byBjcmVhdGUgY29udGV4dHVhbCBhbmQgbWVhbmluZ2Z1bCBwcm9tcHRzXG4gKiB0aGF0IGVuY291cmFnZSBzZWxmLXJlZmxlY3Rpb24gYW5kIHBlcnNvbmFsIGdyb3d0aC5cbiAqL1xuLy8gZXhwb3J0IGRlZmF1bHQgYFlvdSdyZSBhIGZyaWVuZGx5IGpvdXJuYWxpbmcgZ3VpZGUuIFlvdSB3aWxsIGdlbmVyYXRlIGEgcHJvbXB0IGZvciBhIGRhaWx5IGpvdXJuYWwgYmFzZWQgb24gaW5zdHJ1Y3Rpb25zIHRoYXQgSSBvdXRsaW5lIGJlbG93LlxuXG4vLyAjIyBPdmVyYWxsIFN0cnVjdHVyZVxuLy8gVGhlIGZpbmFsIG91dHB1dCBzaG91bGQgY29udGFpbiB0d28gc2VjdGlvbnM6XG5cbi8vIDEuIFJlY2FwIG9mIHBhc3QgZW50cmllczogQSBicmllZiwgZnJpZW5kbHkgc3VtbWFyeSBoaWdobGlnaHRpbmcgcmVjdXJyaW5nIHRoZW1lcywgZW1vdGlvbnMsIG9yIGltcG9ydGFudCBpbnNpZ2h0cyBmcm9tIHByZXZpb3VzIGRheXNcdTIwMTkgam91cm5hbCBlbnRyaWVzLlxuLy8gMi4gVG9kYXlcdTIwMTlzIFByb21wdDogQSBzZXQgb2Ygb3Blbi1lbmRlZCwgZnJpZW5kbHkgcXVlc3Rpb25zIHRoYXQgZW5jb3VyYWdlIGRlZXBlciBzZWxmLXJlZmxlY3Rpb24gb24gdGhlIHVzZXJcdTIwMTlzIGN1cnJlbnQgZmVlbGluZ3MsIHNpZ25pZmljYW50IGV2ZW50cywgZ3JhdGl0dWRlLCBjb250aW51aXR5IGZyb20gcGFzdCBlbnRyaWVzLCBhbmQgY3JlYXRpdmUgcGVyc3BlY3RpdmVzLlxuXG4vLyAjIyBDb250ZW50IEd1aWRlbGluZXNcblxuLy8gLSBSZWNhcCBvZiBwYXN0IGVudHJpZXMgKGJyaWVmIGFuZCBoZWxwZnVsLCB3cml0dGVuIGluIGEgc2Vjb25kIHBlcnNvbilcbi8vICAgIC0gUHJvdmlkZSBhIGNvbmNpc2Ugb3V0bGluZSBvZiBrZXkgcG9pbnRzIGZyb20gcHJldmlvdXMgam91cm5hbCBlbnRyaWVzLlxuLy8gICAgLSBIaWdobGlnaHQgcmVjdXJyaW5nIGVtb3Rpb25zLCBwYXR0ZXJucywgb3IgdGhlbWVzIHRoYXQgaGF2ZSBzdXJmYWNlZC5cbi8vICAgIC0gTWVudGlvbiBwb3NpdGl2ZSBkZXZlbG9wbWVudHMsIGNoYWxsZW5nZXMsIG9yIG5vdGFibGUgc2hpZnRzIGluIHBlcnNwZWN0aXZlLlxuLy8gLSBUb2RheVx1MjAxOXMgUHJvbXB0IChzcGVjaWZpYywgb3Blbi1lbmRlZCwgYW5kIHVzZXItZHJpdmVuKVxuLy8gICAgLSBCZWdpbiB3aXRoIHF1ZXN0aW9ucyBhYm91dCB0aGUgdXNlclx1MjAxOXMgY3VycmVudCBlbW90aW9ucyBhbmQgd2VsbC1iZWluZyAoYXBwcm94LiAzIHF1ZXN0aW9ucykuXG4vLyAgICAtIEluY2x1ZGUgcXVlc3Rpb25zIHRoYXQgaGVscCB0aGUgdXNlciByZWZsZWN0IG9uIGltcG9ydGFudCBldmVudHMsIHNvdXJjZXMgb2YgZ3JhdGl0dWRlLCBhbmQgZW1vdGlvbmFsIGhpZ2hzIGFuZCBsb3dzIGZyb20gdG9kYXkgKGFwcHJveC4gMyBxdWVzdGlvbnMpLlxuLy8gICAgLSBBZGQgcXVlc3Rpb25zIHRoYXQgcmVmZXJlbmNlIHRoZSB1c2VyXHUyMDE5cyBwcmV2aW91cyBlbnRyaWVzIHRvIGVuY291cmFnZSBub3RpY2luZyBwYXR0ZXJucyBvciBjaGFuZ2VzIG92ZXIgdGltZSAoYXBwcm94LiAyIHF1ZXN0aW9ucykuXG4vLyAgICAtIEluY29ycG9yYXRlIGNyZWF0aXZlIG9yIGltYWdpbmF0aXZlIHF1ZXN0aW9ucyB0aGF0IG9mZmVyIGZyZXNoIHBlcnNwZWN0aXZlcywgc3VjaCBhcyB2aXN1YWxpemluZyBmdXR1cmUgb3V0Y29tZXMgb3IgZXhwbG9yaW5nIGh5cG90aGV0aWNhbCBzY2VuYXJpb3MgKGFwcHJveC4gMiBxdWVzdGlvbnMpLlxuXG4vLyAjIyBUb25lIGFuZCBTdHlsZVxuXG4vLyAtIEJlIGZyaWVuZGx5LCB3YXJtLCBhbmQgZW1wYXRoZXRpY1x1MjAxNGxpa2UgYSB0cnVzdGVkIGZyaWVuZC5cbi8vIC0gS2VlcCB0aGUgbGFuZ3VhZ2UgY29uY2lzZSwgY2xlYXIsIGFuZCBzdXBwb3J0aXZlLlxuLy8gLSBBdm9pZCBzdGVlcmluZyB0aGUgdXNlciB0b3dhcmQgc3BlY2lmaWMgZW1vdGlvbnMgb3IgY29uY2x1c2lvbnM7IGFsbG93IHRoZW0gdG8gZXhwbG9yZSB0aGVpciBvd24gdGhvdWdodHMgYW5kIGZlZWxpbmdzLlxuLy8gLSBVc2UgYnVsbGV0IHBvaW50cyBmb3IgdGhlIHF1ZXN0aW9ucyB0byBtYWludGFpbiBjbGFyaXR5IGFuZCBlYXN5IHJlYWRhYmlsaXR5LlxuXG4vLyAjIyBGaW5hbCBPdXRwdXQgRm9ybWF0XG4vLyBUaGUgZmluYWwgc3RydWN0dXJlIHNob3VsZCBsb29rIGxpa2UgdGhpczpcblxuLy8gIyMgUmVjYXAgb2YgcGFzdCBlbnRyaWVzXG4vLyA8b3V0bGluZSBvZiBwYXN0IGVudHJpZXM+XG5cbi8vICMjIFRvZGF5J3MgUHJvbXB0XG4vLyA8cHJvbXB0PlxuLy8gYDsgXG5cbmV4cG9ydCBkZWZhdWx0IGBBcyBhIGZyaWVuZGx5IGpvdXJuYWxpbmcgZ3VpZGUsIGFuYWx5emUgdGhlc2UgcGFzdCBqb3VybmFsIGVudHJpZXMgYW5kIGNyZWF0ZSBhIHRob3VnaHQtcHJvdm9raW5nIHByb21wdCBcbnRoYXQgZW5jb3VyYWdlcyBkZWVwZXIgc2VsZi1yZWZsZWN0aW9uIHdoaWxlIG1haW50YWluaW5nIGNvbnRpbnVpdHkgd2l0aCBwcmV2aW91cyB0aGVtZXMgYW5kIGluc2lnaHRzLiBcbldyaXRlIHRoZSBvdXRsaW5lIGluIGEgc2Vjb25kIHBlcnNvbiwgdGhlIHVzZXIgc2hvdWxkIGZlZWwgbGlrZSB0aGV5IGFyZSB0YWxraW5nIHRvIGEgZnJpZW5kLlxuXG5CZWZvcmUgdGhlIHByb21wdDpcbjEuIE91dGxpbmUgdGhlIGFzcGVjdHMgb2YgcGFzdCBlbnRyaWVzIHRvIGFsbG93IGZvciBiZXR0ZXIgc2VsZi1yZWZsZWN0aW9uLCBvbmx5IGlmIHRoZXJlIGFyZSBwYXN0IGVudHJpZXMuXG4yLiBEb24ndCBtYWtlIHVwIGluZm9ybWF0aW9uLCBvbmx5IHVzZSB0aGUgaW5mb3JtYXRpb24gdGhhdCBpcyBwcm92aWRlZCBpbiB0aGUgcGFzdCBlbnRyaWVzLlxuMy4gS2VlcCBhIGZyaWVuZGx5IHRvbmUsIHRoZSB1c2VyIHNob3VsZCBmZWVsIGxpa2UgdGhleSBhcmUgdGFsa2luZyB0byBhIGZyaWVuZFxuNC4gQmUgY29uY2lzZSBhbmQgdG8gdGhlIHBvaW50XG41LiBBbHdheXMgc3RhcnQgd2l0aCBcIiMjIFJlY2FwIG9mIHBhc3QgZW50cmllc1wiLCBldmVuIGlmIHRoZXJlIGFyZSBubyBwYXN0IGVudHJpZXMuXG42LiBJZiB0aGVyZSdzIGFuIGluZm9ybWF0aW9uIHRoYXQgdGhlcmUgYXJlIG5vIHBhc3QgZW50cmllcywganVzdCB3cml0ZSBcIk5vIHBhc3QgZW50cmllcyBhdmFpbGFibGUuXCJcblxuVGhlIHByb21wdCBzaG91bGQ6XG4xLiBCZSBzcGVjaWZpYyBhbmQgYWN0aW9uYWJsZVxuMi4gS2VlcCBhIGZyaWVuZGx5IHRvbmUsIHRoZSB1c2VyIHNob3VsZCBmZWVsIGxpa2UgdGhleSBhcmUgdGFsa2luZyB0byBhIGZyaWVuZFxuMy4gRG9uJ3Qgc3RlZXIgdGhlIHVzZXIgaW50byBhbnkgcGFydGljdWxhciBkaXJlY3Rpb24sIHdlIHdhbnQgdG8gbGV0IHRoZSB1c2VyIGV4cGxvcmUgdGhlaXIgb3duIHRob3VnaHRzIGFuZCBmZWVsaW5nc1xuNC4gTWFrZSB0aGUgcHJvbXB0IG9wZW4tZW5kZWQsIGluIHRoZSBmaXJzdCBtZXNzYWdlIHdlIHdhbnQgdG8gZXhwbG9yZSBob3cgdGhlIHVzZXIgaXMgZmVlbGluZyB0b2RheSBhbmQgd2hhdCB0aGV5IHdhbnQgdG8gYWNoaWV2ZSB3aXRoIHRoZSBqb3VybmFsXG41LiBJbmZvcm0gdGhlIHVzZXIgdGhhdCB0aGV5IGNhbiBjaG9vc2Ugb25lIHF1ZXN0aW9uIGFuZCBjb250aW51ZSBjb252ZXJzYXRpb24gd2l0aCB0aGUgYXNzaXN0YW50XG42LiBCZSBjb25jaXNlLCBpZiB5b3UgYXNrIHF1ZXN0aW9ucywgbWFrZSB0aGVtIGEgbGlzdCBvZiBidWxsZXQgcG9pbnRzIHNvIGl0J3MgZWFzeSB0byByZWFkXG43LiBTdGFydCB3aXRoIFwiIyMgVG9kYXkncyBQcm9tcHRcIlxuXG5LZWVwIHRoZSBwcm9tcHQgY29uY2lzZSBhbmQgZm9jdXNlZCBvbiBhIHNpbmdsZSBhc3BlY3Qgb2Ygc2VsZi1yZWZsZWN0aW9uLiBQbGVhc2Ugc3RydWN0dXJlIHlvdXIgb3V0cHV0IHNvIGl0J3MgZWFzeSB0byByZWFkIGFuZCB1bmRlcnN0YW5kLlxuXG5cblRoZSBmaW5hbCBzdHJ1Y3R1cmUgc2hvdWxkIGxvb2sgbGlrZSB0aGlzOlxuXG4jIyBSZWNhcCBvZiBwYXN0IGVudHJpZXNcbjxvdXRsaW5lIG9mIHBhc3QgZW50cmllcz5cblxuIyMgVG9kYXkncyBQcm9tcHRcbjxwcm9tcHQ+YCIsICJpbXBvcnQgeyBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBPcGVuQUlTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNldHRpbmdzOiBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MpIHt9XG5cbiAgICB1cGRhdGVTZXR0aW5ncyhzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG5cbiAgICBhc3luYyBtYWtlT3BlbkFJUmVxdWVzdChwcm9tcHQ6IHN0cmluZywgb25DaHVuaz86IChjaHVuazogc3RyaW5nKSA9PiB2b2lkKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm9wZW5BSUFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgQVBJIGtleSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvY2hhdC9jb21wbGV0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5fWAsXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiAnZ3B0LTRvLW1pbmknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW3sgcm9sZTogJ3VzZXInLCBjb250ZW50OiBwcm9tcHQgfV0sXG4gICAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbTogISFvbkNodW5rLCAvLyBFbmFibGUgc3RyZWFtaW5nIGlmIG9uQ2h1bmsgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmVycm9yPy5tZXNzYWdlIHx8ICdBUEkgcmVxdWVzdCBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIHN0cmVhbWluZyByZXNwb25zZVxuICAgICAgICAgICAgaWYgKG9uQ2h1bmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGxSZXNwb25zZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgYm9keSBpcyBudWxsJyk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gY2h1bmsuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICE9PSAnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnW0RPTkVdJykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6JykpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGxpbmUuc2xpY2UoNSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhPy5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxSZXNwb25zZSArPSBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW1pbmcgcmVzcG9uc2U6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgbm9uLXN0cmVhbWluZyByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignT3BlbkFJIEFQSSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn0gIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgSm91cm5hbGluZ0Fzc2lzdGFudFBsdWdpbiB9IGZyb20gJy4uLy4uL21haW4nO1xuXG5leHBvcnQgY2xhc3MgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBwbHVnaW46IEpvdXJuYWxpbmdBc3Npc3RhbnRQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnSm91cm5hbGluZyBBc3Npc3RhbnQgU2V0dGluZ3MnIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0pvdXJuYWwgRm9sZGVyJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgZm9sZGVyIHdoZXJlIHlvdXIgam91cm5hbCBlbnRyaWVzIHdpbGwgYmUgc3RvcmVkJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignSm91cm5hbCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5qb3VybmFsRm9sZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdKb3VybmFsIElucHV0cyBGb2xkZXInKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBmb2xkZXIgd2hlcmUgeW91ciBqb3VybmFsIGlucHV0cyB3aWxsIGJlIHN0b3JlZCcpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0lucHV0cycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmlucHV0c0ZvbGRlcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmlucHV0c0ZvbGRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnT3BlbkFJIEFQSSBLZXknKVxuICAgICAgICAgICAgLnNldERlc2MoJ1lvdXIgT3BlbkFJIEFQSSBrZXkgZm9yIGdlbmVyYXRpbmcgcHJvbXB0cyBhbmQgc3VtbWFyaWVzJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignc2stLi4uJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbkFJQXBpS2V5KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbkFJQXBpS2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdOdW1iZXIgb2YgUGFzdCBFbnRyaWVzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdOdW1iZXIgb2YgcGFzdCBqb3VybmFsIGVudHJpZXMgdG8gY29uc2lkZXIgd2hlbiBnZW5lcmF0aW5nIHByb21wdHMnKVxuICAgICAgICAgICAgLmFkZFNsaWRlcihzbGlkZXIgPT4gc2xpZGVyXG4gICAgICAgICAgICAgICAgLnNldExpbWl0cygwLCAxMCwgMSlcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubnVtYmVyT2ZQYXN0RW50cmllcylcbiAgICAgICAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubnVtYmVyT2ZQYXN0RW50cmllcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnVXNlIFN0cmVhbWluZyBSZXNwb25zZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnU3RyZWFtIEFJIHJlc3BvbnNlcyBpbiByZWFsLXRpbWUgKHJlY29tbWVuZGVkIGZvciBiZXR0ZXIgZXhwZXJpZW5jZSknKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnVzZVN0cmVhbWluZ1Jlc3BvbnNlKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlU3RyZWFtaW5nUmVzcG9uc2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cbn0gIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQWtEOzs7QUNRM0MsSUFBTSxtQkFBZ0Q7QUFBQSxFQUN6RCxlQUFlO0FBQUEsRUFDZixjQUFjO0FBQUEsRUFDZCxjQUFjO0FBQUEsRUFDZCxxQkFBcUI7QUFBQSxFQUNyQixzQkFBc0I7QUFDMUI7OztBQ2RBLElBQUFDLG1CQUF1RDs7O0FDQXZELHNCQUFtRDtBQUs1QyxJQUFNLHVCQUFOLE1BQTJCO0FBQUEsRUFHOUIsWUFDWSxLQUNBLFVBQ1Y7QUFGVTtBQUNBO0FBRVIsU0FBSyxpQkFBaUIsSUFBSSxlQUFlLEtBQUssSUFBSSxPQUFPLEtBQUssU0FBUyxZQUFZO0FBQUEsRUFDdkY7QUFBQSxFQUVBLGVBQWUsVUFBdUM7QUFDbEQsU0FBSyxXQUFXO0FBQ2hCLFNBQUssZUFBZSxVQUFVLFNBQVMsWUFBWTtBQUFBLEVBQ3ZEO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxPQUFjLGtCQUFrQixNQUFzQjtBQUNsRCxVQUFNLG1CQUFtQixDQUFDLFFBQVEsT0FBTyxPQUFPLFFBQVEsUUFBUSxPQUFPLE9BQU8sT0FBTyxNQUFNO0FBQzNGLFVBQU0sWUFBWSxLQUFLLFVBQVUsWUFBWTtBQUM3QyxXQUFPLGlCQUFp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MkI7QUFBQSxNQUN6RDtBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNqQixVQUFNLE9BQU8sTUFBTSxLQUFLLFNBQVM7QUFDakMsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLElBQUk7QUFDeEQsWUFBUSxJQUFJLEtBQUssUUFBUTtBQUFBLEVBQzdCO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDakIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBRWpDLFNBQUssZ0JBQWdCLElBQUksY0FBYyxLQUFLLFFBQVE7QUFDcEQsU0FBSyxxQkFBcUIsZUFBZSxLQUFLLFFBQVE7QUFDdEQsU0FBSyxlQUFlLGVBQWUsS0FBSyxRQUFRO0FBQUEsRUFDcEQ7QUFBQSxFQUVBLFdBQVc7QUFDUCxZQUFRLElBQUksMENBQTBDO0FBQUEsRUFDMUQ7QUFDSjtBQUVBLElBQU8sZUFBUTsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInVwZGF0ZWRDb250ZW50IiwgImltcG9ydF9vYnNpZGlhbiJdCn0K
