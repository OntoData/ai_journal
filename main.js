/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  JournalingAssistantPlugin: () => JournalingAssistantPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  journalFolder: "Journal",
  inputsFolder: "Inputs",
  openAIApiKey: "",
  numberOfPastEntries: 3
};

// src/services/JournalService.ts
var import_obsidian = require("obsidian");

// src/audioTranscriber.ts
var AudioTranscriber = class {
  constructor(vault, apiKey) {
    this.vault = vault;
    this.apiKey = apiKey;
  }
  async transcribeFile(audioFile) {
    var _a;
    try {
      const arrayBuffer = await this.vault.readBinary(audioFile);
      const blob = new Blob([arrayBuffer], { type: "audio/webm" });
      const formData = new FormData();
      formData.append("file", blob, audioFile.name);
      formData.append("model", "whisper-1");
      const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: formData
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(((_a = error.error) == null ? void 0 : _a.message) || "Transcription failed");
      }
      const result = await response.json();
      return result.text;
    } catch (error) {
      console.error("Transcription error:", error);
      throw error;
    }
  }
  static getRecordingEmbedPattern() {
    return /!\[\[Recording \d{14}\.webm\]\]/g;
  }
};

// src/services/JournalService.ts
var JournalService = class {
  constructor(app, settings, openAIService) {
    this.app = app;
    this.settings = settings;
    this.openAIService = openAIService;
  }
  getTodayFileName() {
    const date = new Date();
    return date.toISOString().split("T")[0] + ".md";
  }
  async ensureFolder(folderPath) {
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async getPastJournalEntries(count) {
    const folder = this.app.vault.getAbstractFileByPath(this.settings.journalFolder);
    if (!folder)
      return [];
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.journalFolder + "/")).sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, count);
    const entries = await Promise.all(
      files.map(async (file) => {
        const content = await this.app.vault.read(file);
        return {
          date: file.basename,
          content
        };
      })
    );
    return entries.map((entry) => `Date: ${entry.date}
${entry.content}`);
  }
  async openTodaysJournal() {
    try {
      await this.ensureFolder(this.settings.journalFolder);
      const fileName = this.getTodayFileName();
      const filePath = `${this.settings.journalFolder}/${fileName}`;
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        let initialContent = `# Journal Entry - ${new Date().toLocaleDateString()}

`;
        try {
          const loadingNotice = new import_obsidian.Notice("Generating journal prompt...", 0);
          const pastEntries = await this.getPastJournalEntries(this.settings.numberOfPastEntries);
          const aiPrompt = await this.openAIService.generatePrompt(pastEntries);
          loadingNotice.hide();
          initialContent += `${aiPrompt}

## Your Journal Response

`;
        } catch (error) {
          new import_obsidian.Notice("Error generating prompt: " + error.message);
          initialContent += `## Your Journal Response

`;
        }
        file = await this.app.vault.create(filePath, initialContent);
        new import_obsidian.Notice("Created new journal entry for today");
        console.log(initialContent);
      }
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
    } catch (error) {
      new import_obsidian.Notice("Error opening today's journal: " + error.message);
      console.error("Error opening today's journal:", error);
    }
  }
  async summarizeJournalingSession() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    if (!activeView.file) {
      new import_obsidian.Notice("No file is currently open");
      return;
    }
    try {
      const originalContent = activeView.editor.getValue();
      const fileName = activeView.file.name;
      const inputPath = `${this.settings.inputsFolder}/${fileName}`;
      await this.ensureFolder(this.settings.inputsFolder);
      await this.app.vault.create(inputPath, originalContent);
      let processedContent = await this.processContent(originalContent);
      const responseMatch = processedContent.match(/## Your Journal Response\n\n([\s\S]*$)/);
      if (!responseMatch) {
        new import_obsidian.Notice("Could not find journal response section");
        return;
      }
      const userResponse = responseMatch[1];
      const summary = await this.openAIService.generateSummary(userResponse);
      const updatedContent = processedContent.replace(
        /## Your Journal Response\n\n[\s\S]*$/,
        `## Your Journal Response

${summary}`
      );
      activeView.editor.setValue(updatedContent);
      new import_obsidian.Notice("Journal session summarized");
    } catch (error) {
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Summarization error:", error);
    }
  }
  async processContent(content) {
    const recordingPattern = AudioTranscriber.getRecordingEmbedPattern();
    const recordings = content.match(recordingPattern);
    if (!recordings)
      return content;
    const transcriber = new AudioTranscriber(this.app.vault, this.settings.openAIApiKey);
    let processedContent = content;
    for (const recording of recordings) {
      const fileName = recording.slice(3, -2);
      const file = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
      if (file instanceof import_obsidian.TFile) {
        const transcript = await transcriber.transcribeFile(file);
        processedContent = processedContent.replace(recording, transcript);
      }
    }
    return processedContent;
  }
};

// src/prompts/journalPrompt.ts
var journalPrompt_default = `As a friendly journaling guide, analyze these past journal entries and create a thought-provoking prompt 
that encourages deeper self-reflection while maintaining continuity with previous themes and insights. 
Write the outline in a second person, the user should feel like they are talking to a friend.

Before the prompt:
1. Outline the aspects of past entries to allow for better self-reflection, only if there are past entries.
2. Don't make up information, only use the information that is provided in the past entries.
3. Keep a friendly tone, the user should feel like they are talking to a friend
4. Be concise and to the point
5. Always start with "## Recap of past entries", even if there are no past entries.
6. If there's an information that there are no past entries, just write "No past entries available."

The prompt should:
1. Be specific and actionable
2. Keep a friendly tone, the user should feel like they are talking to a friend
3. Don't steer the user into any particular direction, we want to let the user explore their own thoughts and feelings
4. Make the prompt open-ended, in the first message we want to explore how the user is feeling today and what they want to achieve with the journal
5. Inform the user that they can choose one question and continue conversation with the assistant
6. Be concise, if you ask questions, make them a list of bullet points so it's easy to read
7. Start with "## Today's Prompt"

Keep the prompt concise and focused on a single aspect of self-reflection. Please structure your output so it's easy to read and understand.


The final structure should look like this:

## Recap of past entries
<outline of past entries>

## Today's Prompt
<prompt>`;

// src/prompts/summaryPrompt.ts
var summaryPrompt_default = `As a journaling assistant, analyze this journal entry and create a concise summary that:

1. Identifies the main themes and insights
2. Highlights key realizations or breakthroughs
3. Notes any action items or intentions expressed
4. Preserves the emotional tone of the entry

Focus on extracting the most meaningful elements while maintaining the personal nature of the reflection.`;

// src/services/OpenAIService.ts
var OpenAIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  async generatePrompt(pastEntries) {
    if (!this.settings.openAIApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    const pastEntriesText = pastEntries.length > 0 ? `Past Entries:

${pastEntries.join("\n\n---\n\n")}` : "No past entries available.";
    const prompt = `${journalPrompt_default}

${pastEntriesText}`;
    return await this.makeOpenAIRequest(prompt);
  }
  async generateSummary(content) {
    const prompt = `${summaryPrompt_default}

${content}`;
    return await this.makeOpenAIRequest(prompt);
  }
  async makeOpenAIRequest(prompt) {
    var _a;
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.openAIApiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [{ role: "user", content: prompt }],
          temperature: 0.7
        })
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(((_a = data.error) == null ? void 0 : _a.message) || "API request failed");
      }
      return data.choices[0].message.content;
    } catch (error) {
      console.error("OpenAI API error:", error);
      throw error;
    }
  }
};

// src/settings/SettingTab.ts
var import_obsidian2 = require("obsidian");
var JournalingAssistantSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Journaling Assistant Settings" });
    new import_obsidian2.Setting(containerEl).setName("Journal Folder").setDesc("The folder where your journal entries will be stored").addText((text) => text.setPlaceholder("Journal").setValue(this.plugin.settings.journalFolder).onChange(async (value) => {
      this.plugin.settings.journalFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Journal Inputs Folder").setDesc("The folder where your journal inputs will be stored").addText((text) => text.setPlaceholder("Inputs").setValue(this.plugin.settings.inputsFolder).onChange(async (value) => {
      this.plugin.settings.inputsFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating prompts and summaries").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
      this.plugin.settings.openAIApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Number of Past Entries").setDesc("Number of past journal entries to consider when generating prompts").addSlider((slider) => slider.setLimits(0, 10, 1).setValue(this.plugin.settings.numberOfPastEntries).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.numberOfPastEntries = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/services/TranscriptionService.ts
var import_obsidian3 = require("obsidian");
var TranscriptionService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async transcribeRecordings() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      new import_obsidian3.Notice("Please open a note first");
      return;
    }
    if (!this.settings.openAIApiKey) {
      new import_obsidian3.Notice("OpenAI API key not configured");
      return;
    }
    const editor = activeView.editor;
    const content = editor.getValue();
    const recordingPattern = AudioTranscriber.getRecordingEmbedPattern();
    const recordings = content.match(recordingPattern);
    if (!recordings || recordings.length === 0) {
      new import_obsidian3.Notice("No recordings found in the current note");
      return;
    }
    new import_obsidian3.Notice("Starting transcription...");
    const transcriber = new AudioTranscriber(this.app.vault, this.settings.openAIApiKey);
    let updatedContent = content;
    try {
      for (const recording of recordings) {
        const fileName = recording.slice(3, -2);
        const file = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
        if (file instanceof import_obsidian3.TFile) {
          const transcript = await transcriber.transcribeFile(file);
          updatedContent = updatedContent.replace(recording, transcript);
        }
      }
      editor.setValue(updatedContent);
      new import_obsidian3.Notice("Transcription completed successfully");
    } catch (error) {
      new import_obsidian3.Notice(`Transcription failed: ${error.message}`);
      console.error("Transcription error:", error);
    }
  }
};

// main.ts
var JournalingAssistantPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.openAIService = new OpenAIService(this.settings);
    this.journalService = new JournalService(this.app, this.settings, this.openAIService);
    this.transcriptionService = new TranscriptionService(this.app, this.settings);
    this.addSettingTab(new JournalingAssistantSettingTab(this.app, this));
    this.addRibbonIcon("bot", "Journal with AI", async () => {
      await this.journalService.openTodaysJournal();
    });
    this.addCommands();
  }
  addCommands() {
    this.addCommand({
      id: "open-todays-journal",
      name: "Open Today's Journal",
      callback: async () => {
        await this.journalService.openTodaysJournal();
      }
    });
    this.addCommand({
      id: "transcribe-recordings",
      name: "Transcribe Recordings",
      callback: async () => {
        await this.transcriptionService.transcribeRecordings();
      }
    });
    this.addCommand({
      id: "summarize-journal",
      name: "Summarize Journaling Session",
      callback: async () => {
        await this.journalService.summarizeJournalingSession();
      }
    });
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    console.log(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    console.log("Unloading Journaling Assistant Plugin...");
  }
};
var main_default = JournalingAssistantPlugin;
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL3NlcnZpY2VzL0pvdXJuYWxTZXJ2aWNlLnRzIiwgInNyYy9hdWRpb1RyYW5zY3JpYmVyLnRzIiwgInNyYy9wcm9tcHRzL2pvdXJuYWxQcm9tcHQudHMiLCAic3JjL3Byb21wdHMvc3VtbWFyeVByb21wdC50cyIsICJzcmMvc2VydmljZXMvT3BlbkFJU2VydmljZS50cyIsICJzcmMvc2V0dGluZ3MvU2V0dGluZ1RhYi50cyIsICJzcmMvc2VydmljZXMvVHJhbnNjcmlwdGlvblNlcnZpY2UudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IEFwcCwgUGx1Z2luLCBNYXJrZG93blZpZXcsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncywgREVGQVVMVF9TRVRUSU5HUyB9IGZyb20gJy4vc3JjL3R5cGVzJztcbmltcG9ydCB7IEpvdXJuYWxTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvSm91cm5hbFNlcnZpY2UnO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL09wZW5BSVNlcnZpY2UnO1xuaW1wb3J0IHsgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdUYWIgfSBmcm9tICcuL3NyYy9zZXR0aW5ncy9TZXR0aW5nVGFiJztcbmltcG9ydCB7IEF1ZGlvVHJhbnNjcmliZXIgfSBmcm9tICcuL3NyYy9hdWRpb1RyYW5zY3JpYmVyJztcbmltcG9ydCB7IFRyYW5zY3JpcHRpb25TZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvVHJhbnNjcmlwdGlvblNlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgSm91cm5hbGluZ0Fzc2lzdGFudFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncztcbiAgICBwcml2YXRlIGpvdXJuYWxTZXJ2aWNlOiBKb3VybmFsU2VydmljZTtcbiAgICBwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2U7XG4gICAgcHJpdmF0ZSB0cmFuc2NyaXB0aW9uU2VydmljZTogVHJhbnNjcmlwdGlvblNlcnZpY2U7XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9wZW5BSVNlcnZpY2UgPSBuZXcgT3BlbkFJU2VydmljZSh0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5qb3VybmFsU2VydmljZSA9IG5ldyBKb3VybmFsU2VydmljZSh0aGlzLmFwcCwgdGhpcy5zZXR0aW5ncywgdGhpcy5vcGVuQUlTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy50cmFuc2NyaXB0aW9uU2VydmljZSA9IG5ldyBUcmFuc2NyaXB0aW9uU2VydmljZSh0aGlzLmFwcCwgdGhpcy5zZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gQWRkIHNldHRpbmdzIHRhYlxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIHJpYmJvbiBpY29uXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignYm90JywgJ0pvdXJuYWwgd2l0aCBBSScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuam91cm5hbFNlcnZpY2Uub3BlblRvZGF5c0pvdXJuYWwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ29wZW4tdG9kYXlzLWpvdXJuYWwnLFxuICAgICAgICAgICAgbmFtZTogJ09wZW4gVG9kYXlcXCdzIEpvdXJuYWwnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmpvdXJuYWxTZXJ2aWNlLm9wZW5Ub2RheXNKb3VybmFsKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICd0cmFuc2NyaWJlLXJlY29yZGluZ3MnLFxuICAgICAgICAgICAgbmFtZTogJ1RyYW5zY3JpYmUgUmVjb3JkaW5ncycsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudHJhbnNjcmlwdGlvblNlcnZpY2UudHJhbnNjcmliZVJlY29yZGluZ3MoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ3N1bW1hcml6ZS1qb3VybmFsJyxcbiAgICAgICAgICAgIG5hbWU6ICdTdW1tYXJpemUgSm91cm5hbGluZyBTZXNzaW9uJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5qb3VybmFsU2VydmljZS5zdW1tYXJpemVKb3VybmFsaW5nU2Vzc2lvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgZGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVbmxvYWRpbmcgSm91cm5hbGluZyBBc3Npc3RhbnQgUGx1Z2luLi4uXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSm91cm5hbGluZ0Fzc2lzdGFudFBsdWdpbjtcbiIsICJleHBvcnQgaW50ZXJmYWNlIEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyB7XG4gICAgam91cm5hbEZvbGRlcjogc3RyaW5nO1xuICAgIGlucHV0c0ZvbGRlcjogc3RyaW5nO1xuICAgIG9wZW5BSUFwaUtleTogc3RyaW5nO1xuICAgIG51bWJlck9mUGFzdEVudHJpZXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyA9IHtcbiAgICBqb3VybmFsRm9sZGVyOiAnSm91cm5hbCcsXG4gICAgaW5wdXRzRm9sZGVyOiAnSW5wdXRzJyxcbiAgICBvcGVuQUlBcGlLZXk6ICcnLFxuICAgIG51bWJlck9mUGFzdEVudHJpZXM6IDMsXG59OyAiLCAiaW1wb3J0IHsgQXBwLCBURmlsZSwgTm90aWNlLCBNYXJrZG93blZpZXcsIFZpZXcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBPcGVuQUlTZXJ2aWNlIH0gZnJvbSAnLi9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IEF1ZGlvVHJhbnNjcmliZXIgfSBmcm9tICcuLi9hdWRpb1RyYW5zY3JpYmVyJztcblxuZXhwb3J0IGNsYXNzIEpvdXJuYWxTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBhcHA6IEFwcCxcbiAgICAgICAgcHJpdmF0ZSBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzLFxuICAgICAgICBwcml2YXRlIG9wZW5BSVNlcnZpY2U6IE9wZW5BSVNlcnZpY2VcbiAgICApIHt9XG5cbiAgICBwcml2YXRlIGdldFRvZGF5RmlsZU5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSArICcubWQnOyAvLyBGb3JtYXQ6IFlZWVktTU0tREQubWRcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGVuc3VyZUZvbGRlcihmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMoZm9sZGVyUGF0aCkpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIoZm9sZGVyUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGdldFBhc3RKb3VybmFsRW50cmllcyhjb3VudDogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zZXR0aW5ncy5qb3VybmFsRm9sZGVyKTtcbiAgICAgICAgaWYgKCFmb2xkZXIpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICAgICAgLmZpbHRlcihmaWxlID0+IGZpbGUucGF0aC5zdGFydHNXaXRoKHRoaXMuc2V0dGluZ3Muam91cm5hbEZvbGRlciArICcvJykpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5zdGF0Lm10aW1lIC0gYS5zdGF0Lm10aW1lKVxuICAgICAgICAgICAgLnNsaWNlKDAsIGNvdW50KTtcblxuICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBmaWxlcy5tYXAoYXN5bmMgZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogZmlsZS5iYXNlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBgRGF0ZTogJHtlbnRyeS5kYXRlfVxcbiR7ZW50cnkuY29udGVudH1gKTtcbiAgICB9XG5cbiAgICBhc3luYyBvcGVuVG9kYXlzSm91cm5hbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyKHRoaXMuc2V0dGluZ3Muam91cm5hbEZvbGRlcik7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5nZXRUb2RheUZpbGVOYW1lKCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGAke3RoaXMuc2V0dGluZ3Muam91cm5hbEZvbGRlcn0vJHtmaWxlTmFtZX1gO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGVudCA9IGAjIEpvdXJuYWwgRW50cnkgLSAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nTm90aWNlID0gbmV3IE5vdGljZSgnR2VuZXJhdGluZyBqb3VybmFsIHByb21wdC4uLicsIDApO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdEVudHJpZXMgPSBhd2FpdCB0aGlzLmdldFBhc3RKb3VybmFsRW50cmllcyh0aGlzLnNldHRpbmdzLm51bWJlck9mUGFzdEVudHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhaVByb21wdCA9IGF3YWl0IHRoaXMub3BlbkFJU2VydmljZS5nZW5lcmF0ZVByb21wdChwYXN0RW50cmllcyk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdOb3RpY2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnQgKz0gYCR7YWlQcm9tcHR9XFxuXFxuIyMgWW91ciBKb3VybmFsIFJlc3BvbnNlXFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdFcnJvciBnZW5lcmF0aW5nIHByb21wdDogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGVudCArPSBgIyMgWW91ciBKb3VybmFsIFJlc3BvbnNlXFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWxlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGZpbGVQYXRoLCBpbml0aWFsQ29udGVudCk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnQ3JlYXRlZCBuZXcgam91cm5hbCBlbnRyeSBmb3IgdG9kYXknKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbml0aWFsQ29udGVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUgYXMgVEZpbGUpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdFcnJvciBvcGVuaW5nIHRvZGF5XFwncyBqb3VybmFsOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvcGVuaW5nIHRvZGF5XFwncyBqb3VybmFsOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHN1bW1hcml6ZUpvdXJuYWxpbmdTZXNzaW9uKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgaWYgKCFhY3RpdmVWaWV3KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdQbGVhc2Ugb3BlbiBhIG5vdGUgZmlyc3QnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0aXZlVmlldy5maWxlKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdObyBmaWxlIGlzIGN1cnJlbnRseSBvcGVuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBjb250ZW50IHRvIGlucHV0cyBmb2xkZXJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ29udGVudCA9IGFjdGl2ZVZpZXcuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGFjdGl2ZVZpZXcuZmlsZS5uYW1lO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRQYXRoID0gYCR7dGhpcy5zZXR0aW5ncy5pbnB1dHNGb2xkZXJ9LyR7ZmlsZU5hbWV9YDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXIodGhpcy5zZXR0aW5ncy5pbnB1dHNGb2xkZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGlucHV0UGF0aCwgb3JpZ2luYWxDb250ZW50KTtcblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBjb250ZW50ICh0cmFuc2NyaWJlIHJlY29yZGluZ3MgaWYgYW55KVxuICAgICAgICAgICAgbGV0IHByb2Nlc3NlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnByb2Nlc3NDb250ZW50KG9yaWdpbmFsQ29udGVudCk7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdXNlcidzIHJlc3BvbnNlIHNlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlTWF0Y2ggPSBwcm9jZXNzZWRDb250ZW50Lm1hdGNoKC8jIyBZb3VyIEpvdXJuYWwgUmVzcG9uc2VcXG5cXG4oW1xcc1xcU10qJCkvKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VNYXRjaCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0NvdWxkIG5vdCBmaW5kIGpvdXJuYWwgcmVzcG9uc2Ugc2VjdGlvbicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdXNlclJlc3BvbnNlID0gcmVzcG9uc2VNYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSBhd2FpdCB0aGlzLm9wZW5BSVNlcnZpY2UuZ2VuZXJhdGVTdW1tYXJ5KHVzZXJSZXNwb25zZSk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgcmVzcG9uc2Ugd2l0aCBzdW1tYXJ5XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudCA9IHByb2Nlc3NlZENvbnRlbnQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvIyMgWW91ciBKb3VybmFsIFJlc3BvbnNlXFxuXFxuW1xcc1xcU10qJC8sXG4gICAgICAgICAgICAgICAgYCMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbiR7c3VtbWFyeX1gXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG5vdGVcbiAgICAgICAgICAgIGFjdGl2ZVZpZXcuZWRpdG9yLnNldFZhbHVlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0pvdXJuYWwgc2Vzc2lvbiBzdW1tYXJpemVkJyk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTdW1tYXJpemF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0NvbnRlbnQoY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcmVjb3JkaW5nUGF0dGVybiA9IEF1ZGlvVHJhbnNjcmliZXIuZ2V0UmVjb3JkaW5nRW1iZWRQYXR0ZXJuKCk7XG4gICAgICAgIGNvbnN0IHJlY29yZGluZ3MgPSBjb250ZW50Lm1hdGNoKHJlY29yZGluZ1BhdHRlcm4pO1xuXG4gICAgICAgIGlmICghcmVjb3JkaW5ncykgcmV0dXJuIGNvbnRlbnQ7XG5cbiAgICAgICAgY29uc3QgdHJhbnNjcmliZXIgPSBuZXcgQXVkaW9UcmFuc2NyaWJlcih0aGlzLmFwcC52YXVsdCwgdGhpcy5zZXR0aW5ncy5vcGVuQUlBcGlLZXkpO1xuICAgICAgICBsZXQgcHJvY2Vzc2VkQ29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgZm9yIChjb25zdCByZWNvcmRpbmcgb2YgcmVjb3JkaW5ncykge1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSByZWNvcmRpbmcuc2xpY2UoMywgLTIpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZmlsZU5hbWUsIFwiXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IGF3YWl0IHRyYW5zY3JpYmVyLnRyYW5zY3JpYmVGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSBwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UocmVjb3JkaW5nLCB0cmFuc2NyaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRDb250ZW50O1xuICAgIH1cbn0gIiwgImltcG9ydCB7IE5vdGljZSwgVEZpbGUsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgY2xhc3MgQXVkaW9UcmFuc2NyaWJlciB7XG4gICAgcHJpdmF0ZSB2YXVsdDogVmF1bHQ7XG4gICAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHZhdWx0OiBWYXVsdCwgYXBpS2V5OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy52YXVsdCA9IHZhdWx0O1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG5cbiAgICBhc3luYyB0cmFuc2NyaWJlRmlsZShhdWRpb0ZpbGU6IFRGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkQmluYXJ5KGF1ZGlvRmlsZSk7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwgeyB0eXBlOiAnYXVkaW8vd2VibScgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCBhdWRpb0ZpbGUubmFtZSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ21vZGVsJywgJ3doaXNwZXItMScpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2F1ZGlvL3RyYW5zY3JpcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5hcGlLZXl9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZXJyb3I/Lm1lc3NhZ2UgfHwgJ1RyYW5zY3JpcHRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RyYW5zY3JpcHRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UmVjb3JkaW5nRW1iZWRQYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiAvIVxcW1xcW1JlY29yZGluZyBcXGR7MTR9XFwud2VibVxcXVxcXS9nO1xuICAgIH1cbn0gIiwgIi8qKlxuICogUHJvbXB0IGZvciBnZW5lcmF0aW5nIGRhaWx5IGpvdXJuYWxpbmcgcHJvbXB0c1xuICogVGFrZXMgaW50byBhY2NvdW50IHBhc3Qgam91cm5hbCBlbnRyaWVzIHRvIGNyZWF0ZSBjb250ZXh0dWFsIGFuZCBtZWFuaW5nZnVsIHByb21wdHNcbiAqIHRoYXQgZW5jb3VyYWdlIHNlbGYtcmVmbGVjdGlvbiBhbmQgcGVyc29uYWwgZ3Jvd3RoLlxuICovXG4vLyBleHBvcnQgZGVmYXVsdCBgWW91J3JlIGEgZnJpZW5kbHkgam91cm5hbGluZyBndWlkZS4gWW91IHdpbGwgZ2VuZXJhdGUgYSBwcm9tcHQgZm9yIGEgZGFpbHkgam91cm5hbCBiYXNlZCBvbiBpbnN0cnVjdGlvbnMgdGhhdCBJIG91dGxpbmUgYmVsb3cuXG5cbi8vICMjIE92ZXJhbGwgU3RydWN0dXJlXG4vLyBUaGUgZmluYWwgb3V0cHV0IHNob3VsZCBjb250YWluIHR3byBzZWN0aW9uczpcblxuLy8gMS4gUmVjYXAgb2YgcGFzdCBlbnRyaWVzOiBBIGJyaWVmLCBmcmllbmRseSBzdW1tYXJ5IGhpZ2hsaWdodGluZyByZWN1cnJpbmcgdGhlbWVzLCBlbW90aW9ucywgb3IgaW1wb3J0YW50IGluc2lnaHRzIGZyb20gcHJldmlvdXMgZGF5c1x1MjAxOSBqb3VybmFsIGVudHJpZXMuXG4vLyAyLiBUb2RheVx1MjAxOXMgUHJvbXB0OiBBIHNldCBvZiBvcGVuLWVuZGVkLCBmcmllbmRseSBxdWVzdGlvbnMgdGhhdCBlbmNvdXJhZ2UgZGVlcGVyIHNlbGYtcmVmbGVjdGlvbiBvbiB0aGUgdXNlclx1MjAxOXMgY3VycmVudCBmZWVsaW5ncywgc2lnbmlmaWNhbnQgZXZlbnRzLCBncmF0aXR1ZGUsIGNvbnRpbnVpdHkgZnJvbSBwYXN0IGVudHJpZXMsIGFuZCBjcmVhdGl2ZSBwZXJzcGVjdGl2ZXMuXG5cbi8vICMjIENvbnRlbnQgR3VpZGVsaW5lc1xuXG4vLyAtIFJlY2FwIG9mIHBhc3QgZW50cmllcyAoYnJpZWYgYW5kIGhlbHBmdWwsIHdyaXR0ZW4gaW4gYSBzZWNvbmQgcGVyc29uKVxuLy8gICAgLSBQcm92aWRlIGEgY29uY2lzZSBvdXRsaW5lIG9mIGtleSBwb2ludHMgZnJvbSBwcmV2aW91cyBqb3VybmFsIGVudHJpZXMuXG4vLyAgICAtIEhpZ2hsaWdodCByZWN1cnJpbmcgZW1vdGlvbnMsIHBhdHRlcm5zLCBvciB0aGVtZXMgdGhhdCBoYXZlIHN1cmZhY2VkLlxuLy8gICAgLSBNZW50aW9uIHBvc2l0aXZlIGRldmVsb3BtZW50cywgY2hhbGxlbmdlcywgb3Igbm90YWJsZSBzaGlmdHMgaW4gcGVyc3BlY3RpdmUuXG4vLyAtIFRvZGF5XHUyMDE5cyBQcm9tcHQgKHNwZWNpZmljLCBvcGVuLWVuZGVkLCBhbmQgdXNlci1kcml2ZW4pXG4vLyAgICAtIEJlZ2luIHdpdGggcXVlc3Rpb25zIGFib3V0IHRoZSB1c2VyXHUyMDE5cyBjdXJyZW50IGVtb3Rpb25zIGFuZCB3ZWxsLWJlaW5nIChhcHByb3guIDMgcXVlc3Rpb25zKS5cbi8vICAgIC0gSW5jbHVkZSBxdWVzdGlvbnMgdGhhdCBoZWxwIHRoZSB1c2VyIHJlZmxlY3Qgb24gaW1wb3J0YW50IGV2ZW50cywgc291cmNlcyBvZiBncmF0aXR1ZGUsIGFuZCBlbW90aW9uYWwgaGlnaHMgYW5kIGxvd3MgZnJvbSB0b2RheSAoYXBwcm94LiAzIHF1ZXN0aW9ucykuXG4vLyAgICAtIEFkZCBxdWVzdGlvbnMgdGhhdCByZWZlcmVuY2UgdGhlIHVzZXJcdTIwMTlzIHByZXZpb3VzIGVudHJpZXMgdG8gZW5jb3VyYWdlIG5vdGljaW5nIHBhdHRlcm5zIG9yIGNoYW5nZXMgb3ZlciB0aW1lIChhcHByb3guIDIgcXVlc3Rpb25zKS5cbi8vICAgIC0gSW5jb3Jwb3JhdGUgY3JlYXRpdmUgb3IgaW1hZ2luYXRpdmUgcXVlc3Rpb25zIHRoYXQgb2ZmZXIgZnJlc2ggcGVyc3BlY3RpdmVzLCBzdWNoIGFzIHZpc3VhbGl6aW5nIGZ1dHVyZSBvdXRjb21lcyBvciBleHBsb3JpbmcgaHlwb3RoZXRpY2FsIHNjZW5hcmlvcyAoYXBwcm94LiAyIHF1ZXN0aW9ucykuXG5cbi8vICMjIFRvbmUgYW5kIFN0eWxlXG5cbi8vIC0gQmUgZnJpZW5kbHksIHdhcm0sIGFuZCBlbXBhdGhldGljXHUyMDE0bGlrZSBhIHRydXN0ZWQgZnJpZW5kLlxuLy8gLSBLZWVwIHRoZSBsYW5ndWFnZSBjb25jaXNlLCBjbGVhciwgYW5kIHN1cHBvcnRpdmUuXG4vLyAtIEF2b2lkIHN0ZWVyaW5nIHRoZSB1c2VyIHRvd2FyZCBzcGVjaWZpYyBlbW90aW9ucyBvciBjb25jbHVzaW9uczsgYWxsb3cgdGhlbSB0byBleHBsb3JlIHRoZWlyIG93biB0aG91Z2h0cyBhbmQgZmVlbGluZ3MuXG4vLyAtIFVzZSBidWxsZXQgcG9pbnRzIGZvciB0aGUgcXVlc3Rpb25zIHRvIG1haW50YWluIGNsYXJpdHkgYW5kIGVhc3kgcmVhZGFiaWxpdHkuXG5cbi8vICMjIEZpbmFsIE91dHB1dCBGb3JtYXRcbi8vIFRoZSBmaW5hbCBzdHJ1Y3R1cmUgc2hvdWxkIGxvb2sgbGlrZSB0aGlzOlxuXG4vLyAjIyBSZWNhcCBvZiBwYXN0IGVudHJpZXNcbi8vIDxvdXRsaW5lIG9mIHBhc3QgZW50cmllcz5cblxuLy8gIyMgVG9kYXkncyBQcm9tcHRcbi8vIDxwcm9tcHQ+XG4vLyBgOyBcblxuZXhwb3J0IGRlZmF1bHQgYEFzIGEgZnJpZW5kbHkgam91cm5hbGluZyBndWlkZSwgYW5hbHl6ZSB0aGVzZSBwYXN0IGpvdXJuYWwgZW50cmllcyBhbmQgY3JlYXRlIGEgdGhvdWdodC1wcm92b2tpbmcgcHJvbXB0IFxudGhhdCBlbmNvdXJhZ2VzIGRlZXBlciBzZWxmLXJlZmxlY3Rpb24gd2hpbGUgbWFpbnRhaW5pbmcgY29udGludWl0eSB3aXRoIHByZXZpb3VzIHRoZW1lcyBhbmQgaW5zaWdodHMuIFxuV3JpdGUgdGhlIG91dGxpbmUgaW4gYSBzZWNvbmQgcGVyc29uLCB0aGUgdXNlciBzaG91bGQgZmVlbCBsaWtlIHRoZXkgYXJlIHRhbGtpbmcgdG8gYSBmcmllbmQuXG5cbkJlZm9yZSB0aGUgcHJvbXB0OlxuMS4gT3V0bGluZSB0aGUgYXNwZWN0cyBvZiBwYXN0IGVudHJpZXMgdG8gYWxsb3cgZm9yIGJldHRlciBzZWxmLXJlZmxlY3Rpb24sIG9ubHkgaWYgdGhlcmUgYXJlIHBhc3QgZW50cmllcy5cbjIuIERvbid0IG1ha2UgdXAgaW5mb3JtYXRpb24sIG9ubHkgdXNlIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHByb3ZpZGVkIGluIHRoZSBwYXN0IGVudHJpZXMuXG4zLiBLZWVwIGEgZnJpZW5kbHkgdG9uZSwgdGhlIHVzZXIgc2hvdWxkIGZlZWwgbGlrZSB0aGV5IGFyZSB0YWxraW5nIHRvIGEgZnJpZW5kXG40LiBCZSBjb25jaXNlIGFuZCB0byB0aGUgcG9pbnRcbjUuIEFsd2F5cyBzdGFydCB3aXRoIFwiIyMgUmVjYXAgb2YgcGFzdCBlbnRyaWVzXCIsIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHBhc3QgZW50cmllcy5cbjYuIElmIHRoZXJlJ3MgYW4gaW5mb3JtYXRpb24gdGhhdCB0aGVyZSBhcmUgbm8gcGFzdCBlbnRyaWVzLCBqdXN0IHdyaXRlIFwiTm8gcGFzdCBlbnRyaWVzIGF2YWlsYWJsZS5cIlxuXG5UaGUgcHJvbXB0IHNob3VsZDpcbjEuIEJlIHNwZWNpZmljIGFuZCBhY3Rpb25hYmxlXG4yLiBLZWVwIGEgZnJpZW5kbHkgdG9uZSwgdGhlIHVzZXIgc2hvdWxkIGZlZWwgbGlrZSB0aGV5IGFyZSB0YWxraW5nIHRvIGEgZnJpZW5kXG4zLiBEb24ndCBzdGVlciB0aGUgdXNlciBpbnRvIGFueSBwYXJ0aWN1bGFyIGRpcmVjdGlvbiwgd2Ugd2FudCB0byBsZXQgdGhlIHVzZXIgZXhwbG9yZSB0aGVpciBvd24gdGhvdWdodHMgYW5kIGZlZWxpbmdzXG40LiBNYWtlIHRoZSBwcm9tcHQgb3Blbi1lbmRlZCwgaW4gdGhlIGZpcnN0IG1lc3NhZ2Ugd2Ugd2FudCB0byBleHBsb3JlIGhvdyB0aGUgdXNlciBpcyBmZWVsaW5nIHRvZGF5IGFuZCB3aGF0IHRoZXkgd2FudCB0byBhY2hpZXZlIHdpdGggdGhlIGpvdXJuYWxcbjUuIEluZm9ybSB0aGUgdXNlciB0aGF0IHRoZXkgY2FuIGNob29zZSBvbmUgcXVlc3Rpb24gYW5kIGNvbnRpbnVlIGNvbnZlcnNhdGlvbiB3aXRoIHRoZSBhc3Npc3RhbnRcbjYuIEJlIGNvbmNpc2UsIGlmIHlvdSBhc2sgcXVlc3Rpb25zLCBtYWtlIHRoZW0gYSBsaXN0IG9mIGJ1bGxldCBwb2ludHMgc28gaXQncyBlYXN5IHRvIHJlYWRcbjcuIFN0YXJ0IHdpdGggXCIjIyBUb2RheSdzIFByb21wdFwiXG5cbktlZXAgdGhlIHByb21wdCBjb25jaXNlIGFuZCBmb2N1c2VkIG9uIGEgc2luZ2xlIGFzcGVjdCBvZiBzZWxmLXJlZmxlY3Rpb24uIFBsZWFzZSBzdHJ1Y3R1cmUgeW91ciBvdXRwdXQgc28gaXQncyBlYXN5IHRvIHJlYWQgYW5kIHVuZGVyc3RhbmQuXG5cblxuVGhlIGZpbmFsIHN0cnVjdHVyZSBzaG91bGQgbG9vayBsaWtlIHRoaXM6XG5cbiMjIFJlY2FwIG9mIHBhc3QgZW50cmllc1xuPG91dGxpbmUgb2YgcGFzdCBlbnRyaWVzPlxuXG4jIyBUb2RheSdzIFByb21wdFxuPHByb21wdD5gIiwgIi8qKlxuICogUHJvbXB0IGZvciBzdW1tYXJpemluZyBqb3VybmFsIGVudHJpZXNcbiAqIEV4dHJhY3RzIGtleSBpbnNpZ2h0cywgcGF0dGVybnMsIGFuZCBtZWFuaW5nZnVsIHJlZmxlY3Rpb25zXG4gKiBmcm9tIHRoZSB1c2VyJ3Mgam91cm5hbGluZyBzZXNzaW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBgQXMgYSBqb3VybmFsaW5nIGFzc2lzdGFudCwgYW5hbHl6ZSB0aGlzIGpvdXJuYWwgZW50cnkgYW5kIGNyZWF0ZSBhIGNvbmNpc2Ugc3VtbWFyeSB0aGF0OlxuXG4xLiBJZGVudGlmaWVzIHRoZSBtYWluIHRoZW1lcyBhbmQgaW5zaWdodHNcbjIuIEhpZ2hsaWdodHMga2V5IHJlYWxpemF0aW9ucyBvciBicmVha3Rocm91Z2hzXG4zLiBOb3RlcyBhbnkgYWN0aW9uIGl0ZW1zIG9yIGludGVudGlvbnMgZXhwcmVzc2VkXG40LiBQcmVzZXJ2ZXMgdGhlIGVtb3Rpb25hbCB0b25lIG9mIHRoZSBlbnRyeVxuXG5Gb2N1cyBvbiBleHRyYWN0aW5nIHRoZSBtb3N0IG1lYW5pbmdmdWwgZWxlbWVudHMgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIHBlcnNvbmFsIG5hdHVyZSBvZiB0aGUgcmVmbGVjdGlvbi5gOyAiLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGpvdXJuYWxQcm9tcHQgZnJvbSAnLi4vcHJvbXB0cy9qb3VybmFsUHJvbXB0JztcbmltcG9ydCBzdW1tYXJ5UHJvbXB0IGZyb20gJy4uL3Byb21wdHMvc3VtbWFyeVByb21wdCc7XG5cbmV4cG9ydCBjbGFzcyBPcGVuQUlTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNldHRpbmdzOiBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MpIHt9XG5cbiAgICBhc3luYyBnZW5lcmF0ZVByb21wdChwYXN0RW50cmllczogc3RyaW5nW10pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBBUEkga2V5IG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXN0RW50cmllc1RleHQgPSBwYXN0RW50cmllcy5sZW5ndGggPiAwIFxuICAgICAgICAgICAgPyBgUGFzdCBFbnRyaWVzOlxcblxcbiR7cGFzdEVudHJpZXMuam9pbignXFxuXFxuLS0tXFxuXFxuJyl9YFxuICAgICAgICAgICAgOiAnTm8gcGFzdCBlbnRyaWVzIGF2YWlsYWJsZS4nO1xuXG4gICAgICAgIGNvbnN0IHByb21wdCA9IGAke2pvdXJuYWxQcm9tcHR9XFxuXFxuJHtwYXN0RW50cmllc1RleHR9YDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubWFrZU9wZW5BSVJlcXVlc3QocHJvbXB0KTtcbiAgICB9XG5cbiAgICBhc3luYyBnZW5lcmF0ZVN1bW1hcnkoY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gYCR7c3VtbWFyeVByb21wdH1cXG5cXG4ke2NvbnRlbnR9YDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubWFrZU9wZW5BSVJlcXVlc3QocHJvbXB0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIG1ha2VPcGVuQUlSZXF1ZXN0KHByb21wdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvY2hhdC9jb21wbGV0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5fWAsXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiAnZ3B0LTRvLW1pbmknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW3sgcm9sZTogJ3VzZXInLCBjb250ZW50OiBwcm9tcHQgfV0sXG4gICAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvcj8ubWVzc2FnZSB8fCAnQVBJIHJlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignT3BlbkFJIEFQSSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn0gIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB0eXBlIHsgSm91cm5hbGluZ0Fzc2lzdGFudFBsdWdpbiB9IGZyb20gJy4uLy4uL21haW4nO1xuXG5leHBvcnQgY2xhc3MgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBwbHVnaW46IEpvdXJuYWxpbmdBc3Npc3RhbnRQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnSm91cm5hbGluZyBBc3Npc3RhbnQgU2V0dGluZ3MnIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0pvdXJuYWwgRm9sZGVyJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgZm9sZGVyIHdoZXJlIHlvdXIgam91cm5hbCBlbnRyaWVzIHdpbGwgYmUgc3RvcmVkJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignSm91cm5hbCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5qb3VybmFsRm9sZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdKb3VybmFsIElucHV0cyBGb2xkZXInKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBmb2xkZXIgd2hlcmUgeW91ciBqb3VybmFsIGlucHV0cyB3aWxsIGJlIHN0b3JlZCcpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0lucHV0cycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmlucHV0c0ZvbGRlcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmlucHV0c0ZvbGRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnT3BlbkFJIEFQSSBLZXknKVxuICAgICAgICAgICAgLnNldERlc2MoJ1lvdXIgT3BlbkFJIEFQSSBrZXkgZm9yIGdlbmVyYXRpbmcgcHJvbXB0cyBhbmQgc3VtbWFyaWVzJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignc2stLi4uJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbkFJQXBpS2V5KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbkFJQXBpS2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdOdW1iZXIgb2YgUGFzdCBFbnRyaWVzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdOdW1iZXIgb2YgcGFzdCBqb3VybmFsIGVudHJpZXMgdG8gY29uc2lkZXIgd2hlbiBnZW5lcmF0aW5nIHByb21wdHMnKVxuICAgICAgICAgICAgLmFkZFNsaWRlcihzbGlkZXIgPT4gc2xpZGVyXG4gICAgICAgICAgICAgICAgLnNldExpbWl0cygwLCAxMCwgMSlcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubnVtYmVyT2ZQYXN0RW50cmllcylcbiAgICAgICAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubnVtYmVyT2ZQYXN0RW50cmllcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxufSAiLCAiaW1wb3J0IHsgTm90aWNlLCBNYXJrZG93blZpZXcsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQXVkaW9UcmFuc2NyaWJlciB9IGZyb20gJy4uL2F1ZGlvVHJhbnNjcmliZXInO1xuaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zY3JpcHRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBhcHA6IEFwcCxcbiAgICAgICAgcHJpdmF0ZSBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzXG4gICAgKSB7fVxuXG4gICAgYXN5bmMgdHJhbnNjcmliZVJlY29yZGluZ3MoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBpZiAoIWFjdGl2ZVZpZXcpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBvcGVuIGEgbm90ZSBmaXJzdCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm9wZW5BSUFwaUtleSkge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnT3BlbkFJIEFQSSBrZXkgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVZpZXcuZWRpdG9yO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHJlY29yZGluZ1BhdHRlcm4gPSBBdWRpb1RyYW5zY3JpYmVyLmdldFJlY29yZGluZ0VtYmVkUGF0dGVybigpO1xuICAgICAgICBjb25zdCByZWNvcmRpbmdzID0gY29udGVudC5tYXRjaChyZWNvcmRpbmdQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoIXJlY29yZGluZ3MgfHwgcmVjb3JkaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIHJlY29yZGluZ3MgZm91bmQgaW4gdGhlIGN1cnJlbnQgbm90ZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IE5vdGljZSgnU3RhcnRpbmcgdHJhbnNjcmlwdGlvbi4uLicpO1xuXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpYmVyID0gbmV3IEF1ZGlvVHJhbnNjcmliZXIodGhpcy5hcHAudmF1bHQsIHRoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5KTtcbiAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gY29udGVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmRpbmcgb2YgcmVjb3JkaW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVjb3JkaW5nLnNsaWNlKDMsIC0yKTsgLy8gUmVtb3ZlICFbWy4uLl1dXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZmlsZU5hbWUsIFwiXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IGF3YWl0IHRyYW5zY3JpYmVyLnRyYW5zY3JpYmVGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQ29udGVudCA9IHVwZGF0ZWRDb250ZW50LnJlcGxhY2UocmVjb3JkaW5nLCB0cmFuc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdUcmFuc2NyaXB0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRyYW5zY3JpcHRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUcmFuc2NyaXB0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn0gIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQWtEOzs7QUNPM0MsSUFBTSxtQkFBZ0Q7QUFBQSxFQUN6RCxlQUFlO0FBQUEsRUFDZixjQUFjO0FBQUEsRUFDZCxjQUFjO0FBQUEsRUFDZCxxQkFBcUI7QUFDekI7OztBQ1pBLHNCQUF1RDs7O0FDRWhELElBQU0sbUJBQU4sTUFBdUI7QUFBQSxFQUkxQixZQUFZLE9BQWMsUUFBZ0I7QUFDdEMsU0FBSyxRQUFRO0FBQ2IsU0FBSyxTQUFTO0FBQUEsRUFDbEI7QUFBQSxFQUVBLE1BQU0sZUFBZSxXQUFtQztBQVg1RDtBQVlRLFFBQUk7QUFDQSxZQUFN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TUFDTixVQUFVLFlBQVk7QUFDbEIsY0FBTSxLQUFLLGVBQWUsa0JBQWtCO0FBQUEsTUFDaEQ7QUFBQSxJQUNKLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNaLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsWUFBWTtBQUNsQixjQUFNLEtBQUsscUJBQXFCLHFCQUFxQjtBQUFBLE1BQ3pEO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLFlBQVk7QUFDbEIsY0FBTSxLQUFLLGVBQWUsMkJBQTJCO0FBQUEsTUFDekQ7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDakIsVUFBTSxPQUFPLE1BQU0sS0FBSyxTQUFTO0FBQ2pDLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixJQUFJO0FBQ3hELFlBQVEsSUFBSSxLQUFLLFFBQVE7QUFBQSxFQUM3QjtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ3JDO0FBQUEsRUFFQSxXQUFXO0FBQ1AsWUFBUSxJQUFJLDBDQUEwQztBQUFBLEVBQzFEO0FBQ0o7QUFFQSxJQUFPLGVBQVE7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIl0KfQo=
