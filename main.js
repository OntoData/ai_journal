/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  JournalingAssistantPlugin: () => JournalingAssistantPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  journalFolder: "Journal",
  inputsFolder: "Inputs",
  openAIApiKey: "",
  numberOfPastEntries: 3
};

// src/services/JournalService.ts
var import_obsidian2 = require("obsidian");

// src/services/AudioProcessingService.ts
var AudioProcessingService = class {
  constructor(vault) {
    this.vault = vault;
  }
  /**
   * Checks if the file format is directly supported by Whisper API
   * @see https://platform.openai.com/docs/api-reference/audio/createTranscription
   */
  static isSupportedFormat(file) {
    const supportedFormats = ["flac", "mp3", "mp4", "mpeg", "mpga", "m4a", "ogg", "wav", "webm"];
    const extension = file.extension.toLowerCase();
    return supportedFormats.includes(extension);
  }
  /**
   * Prepares audio file for transcription
   * Returns a Blob in a supported format
   */
  async prepareAudioForTranscription(file) {
    const arrayBuffer = await this.vault.readBinary(file);
    const extension = file.extension.toLowerCase();
    const mimeTypes = {
      "flac": "audio/flac",
      "mp3": "audio/mpeg",
      "mp4": "audio/mp4",
      "mpeg": "audio/mpeg",
      "mpga": "audio/mpeg",
      "m4a": "audio/mp4",
      "ogg": "audio/ogg",
      "wav": "audio/wav",
      "webm": "audio/webm"
    };
    const mimeType = mimeTypes[extension];
    if (!mimeType) {
      throw new Error(`Unsupported MIME type for extension: ${extension}`);
    }
    return {
      blob: new Blob([arrayBuffer], { type: mimeType }),
      mimeType
    };
  }
};

// src/services/WhisperService.ts
var WhisperService = class {
  constructor(vault, apiKey) {
    this.vault = vault;
    this.apiKey = apiKey;
    if (!apiKey) {
      throw new Error("OpenAI API key is required");
    }
    this.audioProcessor = new AudioProcessingService(vault);
  }
  async transcribeFile(audioFile) {
    var _a;
    try {
      if (!AudioProcessingService.isSupportedFormat(audioFile)) {
        throw new Error(`Unsupported audio format: ${audioFile.extension}`);
      }
      const { blob, mimeType } = await this.audioProcessor.prepareAudioForTranscription(audioFile);
      const formData = new FormData();
      formData.append("file", blob, `${audioFile.basename}.${audioFile.extension}`);
      formData.append("model", "whisper-1");
      const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: formData
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(((_a = error.error) == null ? void 0 : _a.message) || "Transcription failed");
      }
      const result = await response.json();
      return result.text;
    } catch (error) {
      console.error("Transcription error:", error);
      throw error;
    }
  }
};

// src/services/TranscriptionService.ts
var import_obsidian = require("obsidian");
var TranscriptionService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.whisperService = new WhisperService(this.app.vault, this.settings.openAIApiKey);
  }
  /**
   * Returns a RegExp pattern that matches Obsidian's embed syntax for supported audio formats
   * @see https://platform.openai.com/docs/api-reference/audio/createTranscription
   */
  static getRecordingEmbedPattern() {
    return /!\[\[.+\.(flac|mp3|mp4|mpeg|mpga|m4a|ogg|wav|webm)\]\]/g;
  }
  async transcribeRecordings() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      new import_obsidian.Notice("Please open a note first");
      return;
    }
    if (!this.settings.openAIApiKey) {
      new import_obsidian.Notice("OpenAI API key not configured");
      return;
    }
    const editor = activeView.editor;
    const content = editor.getValue();
    const recordingPattern = TranscriptionService.getRecordingEmbedPattern();
    const recordings = content.match(recordingPattern);
    if (!recordings || recordings.length === 0) {
      new import_obsidian.Notice("No recordings found in the current note");
      return;
    }
    new import_obsidian.Notice("Starting transcription...");
    let updatedContent = content;
    let hasErrors = false;
    try {
      for (const recording of recordings) {
        const fileName = recording.slice(3, -2);
        const file = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
        if (!(file instanceof import_obsidian.TFile)) {
          new import_obsidian.Notice(`Could not find file: ${fileName}`);
          hasErrors = true;
          continue;
        }
        try {
          const transcript = await this.whisperService.transcribeFile(file);
          updatedContent = updatedContent.replace(recording, transcript);
        } catch (error) {
          new import_obsidian.Notice(`Failed to transcribe ${fileName}: ${error.message}`);
          hasErrors = true;
          continue;
        }
      }
      editor.setValue(updatedContent);
      if (hasErrors) {
        new import_obsidian.Notice("Transcription completed with some errors");
      } else {
        new import_obsidian.Notice("Transcription completed successfully");
      }
    } catch (error) {
      new import_obsidian.Notice(`Transcription failed: ${error.message}`);
      console.error("Transcription error:", error);
    }
  }
};

// src/services/JournalService.ts
var JournalService = class {
  constructor(app, settings, openAIService) {
    this.app = app;
    this.settings = settings;
    this.openAIService = openAIService;
    this.whisperService = new WhisperService(this.app.vault, this.settings.openAIApiKey);
  }
  getTodayFileName() {
    const date = new Date();
    return date.toISOString().split("T")[0] + ".md";
  }
  async ensureFolder(folderPath) {
    if (!await this.app.vault.adapter.exists(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async getPastJournalEntries(count) {
    const folder = this.app.vault.getAbstractFileByPath(this.settings.journalFolder);
    if (!folder)
      return [];
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.journalFolder + "/")).sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, count);
    const entries = await Promise.all(
      files.map(async (file) => {
        const content = await this.app.vault.read(file);
        return {
          date: file.basename,
          content
        };
      })
    );
    return entries.map((entry) => `Date: ${entry.date}
${entry.content}`);
  }
  async openTodaysJournal() {
    try {
      await this.ensureFolder(this.settings.journalFolder);
      const fileName = this.getTodayFileName();
      const filePath = `${this.settings.journalFolder}/${fileName}`;
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        let initialContent = `# Journal Entry - ${new Date().toLocaleDateString()}

`;
        try {
          const loadingNotice = new import_obsidian2.Notice("Generating journal prompt...", 0);
          const pastEntries = await this.getPastJournalEntries(this.settings.numberOfPastEntries);
          const aiPrompt = await this.openAIService.generatePrompt(pastEntries);
          loadingNotice.hide();
          initialContent += `${aiPrompt}

## Your Journal Response

`;
        } catch (error) {
          new import_obsidian2.Notice("Error generating prompt: " + error.message);
          initialContent += `## Your Journal Response

`;
        }
        file = await this.app.vault.create(filePath, initialContent);
        new import_obsidian2.Notice("Created new journal entry for today");
        console.log(initialContent);
      }
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
    } catch (error) {
      new import_obsidian2.Notice("Error opening today's journal: " + error.message);
      console.error("Error opening today's journal:", error);
    }
  }
  async summarizeJournalingSession() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!activeView) {
      new import_obsidian2.Notice("Please open a note first");
      return;
    }
    if (!activeView.file) {
      new import_obsidian2.Notice("No file is currently open");
      return;
    }
    try {
      const originalContent = activeView.editor.getValue();
      const fileName = activeView.file.name;
      const inputPath = `${this.settings.inputsFolder}/${fileName}`;
      await this.ensureFolder(this.settings.inputsFolder);
      await this.app.vault.create(inputPath, originalContent);
      let processedContent = await this.processContent(originalContent);
      const responseMatch = processedContent.match(/## Your Journal Response\n\n([\s\S]*$)/);
      if (!responseMatch) {
        new import_obsidian2.Notice("Could not find journal response section");
        return;
      }
      const userResponse = responseMatch[1];
      const summary = await this.openAIService.generateSummary(userResponse);
      const updatedContent = processedContent.replace(
        /## Your Journal Response\n\n[\s\S]*$/,
        `## Your Journal Response

${summary}`
      );
      activeView.editor.setValue(updatedContent);
      new import_obsidian2.Notice("Journal session summarized");
    } catch (error) {
      new import_obsidian2.Notice(`Error: ${error.message}`);
      console.error("Summarization error:", error);
    }
  }
  async processContent(content) {
    const recordingPattern = TranscriptionService.getRecordingEmbedPattern();
    const recordings = content.match(recordingPattern);
    if (!recordings)
      return content;
    let processedContent = content;
    for (const recording of recordings) {
      const fileName = recording.slice(3, -2);
      const file = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
      if (file instanceof import_obsidian2.TFile) {
        const transcript = await this.whisperService.transcribeFile(file);
        processedContent = processedContent.replace(recording, transcript);
      }
    }
    return processedContent;
  }
};

// src/prompts/journalPrompt.ts
var journalPrompt_default = `As a friendly journaling guide, analyze these past journal entries and create a thought-provoking prompt 
that encourages deeper self-reflection while maintaining continuity with previous themes and insights. 
Write the outline in a second person, the user should feel like they are talking to a friend.

Before the prompt:
1. Outline the aspects of past entries to allow for better self-reflection, only if there are past entries.
2. Don't make up information, only use the information that is provided in the past entries.
3. Keep a friendly tone, the user should feel like they are talking to a friend
4. Be concise and to the point
5. Always start with "## Recap of past entries", even if there are no past entries.
6. If there's an information that there are no past entries, just write "No past entries available."

The prompt should:
1. Be specific and actionable
2. Keep a friendly tone, the user should feel like they are talking to a friend
3. Don't steer the user into any particular direction, we want to let the user explore their own thoughts and feelings
4. Make the prompt open-ended, in the first message we want to explore how the user is feeling today and what they want to achieve with the journal
5. Inform the user that they can choose one question and continue conversation with the assistant
6. Be concise, if you ask questions, make them a list of bullet points so it's easy to read
7. Start with "## Today's Prompt"

Keep the prompt concise and focused on a single aspect of self-reflection. Please structure your output so it's easy to read and understand.


The final structure should look like this:

## Recap of past entries
<outline of past entries>

## Today's Prompt
<prompt>`;

// src/prompts/summaryPrompt.ts
var summaryPrompt_default = `As a journaling assistant, analyze this journal entry and create a concise summary that:

1. Identifies the main themes and insights
2. Highlights key realizations or breakthroughs
3. Notes any action items or intentions expressed
4. Preserves the emotional tone of the entry

Focus on extracting the most meaningful elements while maintaining the personal nature of the reflection.`;

// src/services/OpenAIService.ts
var OpenAIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  async generatePrompt(pastEntries) {
    if (!this.settings.openAIApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    const pastEntriesText = pastEntries.length > 0 ? `Past Entries:

${pastEntries.join("\n\n---\n\n")}` : "No past entries available.";
    const prompt = `${journalPrompt_default}

${pastEntriesText}`;
    return await this.makeOpenAIRequest(prompt);
  }
  async generateSummary(content) {
    const prompt = `${summaryPrompt_default}

${content}`;
    return await this.makeOpenAIRequest(prompt);
  }
  async makeOpenAIRequest(prompt) {
    var _a;
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.openAIApiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [{ role: "user", content: prompt }],
          temperature: 0.7
        })
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(((_a = data.error) == null ? void 0 : _a.message) || "API request failed");
      }
      return data.choices[0].message.content;
    } catch (error) {
      console.error("OpenAI API error:", error);
      throw error;
    }
  }
};

// src/settings/SettingTab.ts
var import_obsidian3 = require("obsidian");
var JournalingAssistantSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Journaling Assistant Settings" });
    new import_obsidian3.Setting(containerEl).setName("Journal Folder").setDesc("The folder where your journal entries will be stored").addText((text) => text.setPlaceholder("Journal").setValue(this.plugin.settings.journalFolder).onChange(async (value) => {
      this.plugin.settings.journalFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Journal Inputs Folder").setDesc("The folder where your journal inputs will be stored").addText((text) => text.setPlaceholder("Inputs").setValue(this.plugin.settings.inputsFolder).onChange(async (value) => {
      this.plugin.settings.inputsFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for generating prompts and summaries").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
      this.plugin.settings.openAIApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Number of Past Entries").setDesc("Number of past journal entries to consider when generating prompts").addSlider((slider) => slider.setLimits(0, 10, 1).setValue(this.plugin.settings.numberOfPastEntries).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.numberOfPastEntries = value;
      await this.plugin.saveSettings();
    }));
  }
};

// main.ts
var JournalingAssistantPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.openAIService = new OpenAIService(this.settings);
    this.journalService = new JournalService(this.app, this.settings, this.openAIService);
    this.transcriptionService = new TranscriptionService(this.app, this.settings);
    this.addSettingTab(new JournalingAssistantSettingTab(this.app, this));
    this.addRibbonIcon("bot", "Journal with AI", async () => {
      await this.journalService.openTodaysJournal();
    });
    this.addCommands();
  }
  addCommands() {
    this.addCommand({
      id: "open-todays-journal",
      name: "Open Today's Journal",
      callback: async () => {
        await this.journalService.openTodaysJournal();
      }
    });
    this.addCommand({
      id: "transcribe-recordings",
      name: "Transcribe Recordings",
      callback: async () => {
        await this.transcriptionService.transcribeRecordings();
      }
    });
    this.addCommand({
      id: "summarize-journal",
      name: "Summarize Journaling Session",
      callback: async () => {
        await this.journalService.summarizeJournalingSession();
      }
    });
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    console.log(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    console.log("Unloading Journaling Assistant Plugin...");
  }
};
var main_default = JournalingAssistantPlugin;
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL3NlcnZpY2VzL0pvdXJuYWxTZXJ2aWNlLnRzIiwgInNyYy9zZXJ2aWNlcy9BdWRpb1Byb2Nlc3NpbmdTZXJ2aWNlLnRzIiwgInNyYy9zZXJ2aWNlcy9XaGlzcGVyU2VydmljZS50cyIsICJzcmMvc2VydmljZXMvVHJhbnNjcmlwdGlvblNlcnZpY2UudHMiLCAic3JjL3Byb21wdHMvam91cm5hbFByb21wdC50cyIsICJzcmMvcHJvbXB0cy9zdW1tYXJ5UHJvbXB0LnRzIiwgInNyYy9zZXJ2aWNlcy9PcGVuQUlTZXJ2aWNlLnRzIiwgInNyYy9zZXR0aW5ncy9TZXR0aW5nVGFiLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBBcHAsIFBsdWdpbiwgTWFya2Rvd25WaWV3LCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3NyYy90eXBlcyc7XG5pbXBvcnQgeyBKb3VybmFsU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL0pvdXJuYWxTZXJ2aWNlJztcbmltcG9ydCB7IE9wZW5BSVNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9PcGVuQUlTZXJ2aWNlJztcbmltcG9ydCB7IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5nVGFiIH0gZnJvbSAnLi9zcmMvc2V0dGluZ3MvU2V0dGluZ1RhYic7XG5pbXBvcnQgeyBUcmFuc2NyaXB0aW9uU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL1RyYW5zY3JpcHRpb25TZXJ2aWNlJztcblxuZXhwb3J0IGNsYXNzIEpvdXJuYWxpbmdBc3Npc3RhbnRQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHNldHRpbmdzOiBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3M7XG4gICAgcHJpdmF0ZSBqb3VybmFsU2VydmljZTogSm91cm5hbFNlcnZpY2U7XG4gICAgcHJpdmF0ZSBvcGVuQUlTZXJ2aWNlOiBPcGVuQUlTZXJ2aWNlO1xuICAgIHByaXZhdGUgdHJhbnNjcmlwdGlvblNlcnZpY2U6IFRyYW5zY3JpcHRpb25TZXJ2aWNlO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5vcGVuQUlTZXJ2aWNlID0gbmV3IE9wZW5BSVNlcnZpY2UodGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuam91cm5hbFNlcnZpY2UgPSBuZXcgSm91cm5hbFNlcnZpY2UodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MsIHRoaXMub3BlbkFJU2VydmljZSk7XG4gICAgICAgIHRoaXMudHJhbnNjcmlwdGlvblNlcnZpY2UgPSBuZXcgVHJhbnNjcmlwdGlvblNlcnZpY2UodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgICAgIC8vIEFkZCBzZXR0aW5ncyB0YWJcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgICAgIC8vIEFkZCByaWJib24gaWNvblxuICAgICAgICB0aGlzLmFkZFJpYmJvbkljb24oJ2JvdCcsICdKb3VybmFsIHdpdGggQUknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmpvdXJuYWxTZXJ2aWNlLm9wZW5Ub2RheXNKb3VybmFsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZHMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZENvbW1hbmRzKCkge1xuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdvcGVuLXRvZGF5cy1qb3VybmFsJyxcbiAgICAgICAgICAgIG5hbWU6ICdPcGVuIFRvZGF5XFwncyBKb3VybmFsJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5qb3VybmFsU2VydmljZS5vcGVuVG9kYXlzSm91cm5hbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAndHJhbnNjcmliZS1yZWNvcmRpbmdzJyxcbiAgICAgICAgICAgIG5hbWU6ICdUcmFuc2NyaWJlIFJlY29yZGluZ3MnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zY3JpcHRpb25TZXJ2aWNlLnRyYW5zY3JpYmVSZWNvcmRpbmdzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdzdW1tYXJpemUtam91cm5hbCcsXG4gICAgICAgICAgICBuYW1lOiAnU3VtbWFyaXplIEpvdXJuYWxpbmcgU2Vzc2lvbicsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuam91cm5hbFNlcnZpY2Uuc3VtbWFyaXplSm91cm5hbGluZ1Nlc3Npb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMubG9hZERhdGEoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGRhdGEpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5sb2FkaW5nIEpvdXJuYWxpbmcgQXNzaXN0YW50IFBsdWdpbi4uLlwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpvdXJuYWxpbmdBc3Npc3RhbnRQbHVnaW47XG4iLCAiZXhwb3J0IGludGVyZmFjZSBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3Mge1xuICAgIGpvdXJuYWxGb2xkZXI6IHN0cmluZztcbiAgICBpbnB1dHNGb2xkZXI6IHN0cmluZztcbiAgICBvcGVuQUlBcGlLZXk6IHN0cmluZztcbiAgICBudW1iZXJPZlBhc3RFbnRyaWVzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MgPSB7XG4gICAgam91cm5hbEZvbGRlcjogJ0pvdXJuYWwnLFxuICAgIGlucHV0c0ZvbGRlcjogJ0lucHV0cycsXG4gICAgb3BlbkFJQXBpS2V5OiAnJyxcbiAgICBudW1iZXJPZlBhc3RFbnRyaWVzOiAzLFxufTsgIiwgImltcG9ydCB7IEFwcCwgVEZpbGUsIE5vdGljZSwgTWFya2Rvd25WaWV3LCBWaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgT3BlbkFJU2VydmljZSB9IGZyb20gJy4vT3BlbkFJU2VydmljZSc7XG5pbXBvcnQgeyBXaGlzcGVyU2VydmljZSB9IGZyb20gJy4vV2hpc3BlclNlcnZpY2UnO1xuaW1wb3J0IHsgVHJhbnNjcmlwdGlvblNlcnZpY2UgfSBmcm9tICcuL1RyYW5zY3JpcHRpb25TZXJ2aWNlJztcblxuZXhwb3J0IGNsYXNzIEpvdXJuYWxTZXJ2aWNlIHtcbiAgICBwcml2YXRlIHdoaXNwZXJTZXJ2aWNlOiBXaGlzcGVyU2VydmljZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGFwcDogQXBwLFxuICAgICAgICBwcml2YXRlIHNldHRpbmdzOiBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3MsXG4gICAgICAgIHByaXZhdGUgb3BlbkFJU2VydmljZTogT3BlbkFJU2VydmljZVxuICAgICkge1xuICAgICAgICB0aGlzLndoaXNwZXJTZXJ2aWNlID0gbmV3IFdoaXNwZXJTZXJ2aWNlKHRoaXMuYXBwLnZhdWx0LCB0aGlzLnNldHRpbmdzLm9wZW5BSUFwaUtleSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb2RheUZpbGVOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gKyAnLm1kJzsgLy8gRm9ybWF0OiBZWVlZLU1NLURELm1kXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBlbnN1cmVGb2xkZXIoZm9sZGVyUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZvbGRlclBhdGgpKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKGZvbGRlclBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRQYXN0Sm91cm5hbEVudHJpZXMoY291bnQ6IG51bWJlcik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuc2V0dGluZ3Muam91cm5hbEZvbGRlcik7XG4gICAgICAgIGlmICghZm9sZGVyKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aCh0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIgKyAnLycpKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc3RhdC5tdGltZSAtIGEuc3RhdC5tdGltZSlcbiAgICAgICAgICAgIC5zbGljZSgwLCBjb3VudCk7XG5cbiAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZmlsZXMubWFwKGFzeW5jIGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGZpbGUuYmFzZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZW50cmllcy5tYXAoZW50cnkgPT4gYERhdGU6ICR7ZW50cnkuZGF0ZX1cXG4ke2VudHJ5LmNvbnRlbnR9YCk7XG4gICAgfVxuXG4gICAgYXN5bmMgb3BlblRvZGF5c0pvdXJuYWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUZvbGRlcih0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXIpO1xuXG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZ2V0VG9kYXlGaWxlTmFtZSgpO1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBgJHt0aGlzLnNldHRpbmdzLmpvdXJuYWxGb2xkZXJ9LyR7ZmlsZU5hbWV9YDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbENvbnRlbnQgPSBgIyBKb3VybmFsIEVudHJ5IC0gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZGluZ05vdGljZSA9IG5ldyBOb3RpY2UoJ0dlbmVyYXRpbmcgam91cm5hbCBwcm9tcHQuLi4nLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3RFbnRyaWVzID0gYXdhaXQgdGhpcy5nZXRQYXN0Sm91cm5hbEVudHJpZXModGhpcy5zZXR0aW5ncy5udW1iZXJPZlBhc3RFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWlQcm9tcHQgPSBhd2FpdCB0aGlzLm9wZW5BSVNlcnZpY2UuZ2VuZXJhdGVQcm9tcHQocGFzdEVudHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nTm90aWNlLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZW50ICs9IGAke2FpUHJvbXB0fVxcblxcbiMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3IgZ2VuZXJhdGluZyBwcm9tcHQ6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnQgKz0gYCMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlsZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgaW5pdGlhbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0NyZWF0ZWQgbmV3IGpvdXJuYWwgZW50cnkgZm9yIHRvZGF5Jyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5pdGlhbENvbnRlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgICAgICAgYXdhaXQgbGVhZi5vcGVuRmlsZShmaWxlIGFzIFRGaWxlKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3Igb3BlbmluZyB0b2RheVxcJ3Mgam91cm5hbDogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igb3BlbmluZyB0b2RheVxcJ3Mgam91cm5hbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBzdW1tYXJpemVKb3VybmFsaW5nU2Vzc2lvbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGlmICghYWN0aXZlVmlldykge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBub3RlIGZpcnN0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFjdGl2ZVZpZXcuZmlsZSkge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnTm8gZmlsZSBpcyBjdXJyZW50bHkgb3BlbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgY29udGVudCB0byBpbnB1dHMgZm9sZGVyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbENvbnRlbnQgPSBhY3RpdmVWaWV3LmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBhY3RpdmVWaWV3LmZpbGUubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0UGF0aCA9IGAke3RoaXMuc2V0dGluZ3MuaW5wdXRzRm9sZGVyfS8ke2ZpbGVOYW1lfWA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyKHRoaXMuc2V0dGluZ3MuaW5wdXRzRm9sZGVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShpbnB1dFBhdGgsIG9yaWdpbmFsQ29udGVudCk7XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgY29udGVudCAodHJhbnNjcmliZSByZWNvcmRpbmdzIGlmIGFueSlcbiAgICAgICAgICAgIGxldCBwcm9jZXNzZWRDb250ZW50ID0gYXdhaXQgdGhpcy5wcm9jZXNzQ29udGVudChvcmlnaW5hbENvbnRlbnQpO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHVzZXIncyByZXNwb25zZSBzZWN0aW9uXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZU1hdGNoID0gcHJvY2Vzc2VkQ29udGVudC5tYXRjaCgvIyMgWW91ciBKb3VybmFsIFJlc3BvbnNlXFxuXFxuKFtcXHNcXFNdKiQpLyk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdDb3VsZCBub3QgZmluZCBqb3VybmFsIHJlc3BvbnNlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXNwb25zZSA9IHJlc3BvbnNlTWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgdGhpcy5vcGVuQUlTZXJ2aWNlLmdlbmVyYXRlU3VtbWFyeSh1c2VyUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHJlc3BvbnNlIHdpdGggc3VtbWFyeVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZENvbnRlbnQgPSBwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgLyMjIFlvdXIgSm91cm5hbCBSZXNwb25zZVxcblxcbltcXHNcXFNdKiQvLFxuICAgICAgICAgICAgICAgIGAjIyBZb3VyIEpvdXJuYWwgUmVzcG9uc2VcXG5cXG4ke3N1bW1hcnl9YFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBub3RlXG4gICAgICAgICAgICBhY3RpdmVWaWV3LmVkaXRvci5zZXRWYWx1ZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdKb3VybmFsIHNlc3Npb24gc3VtbWFyaXplZCcpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignU3VtbWFyaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHByb2Nlc3NDb250ZW50KGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHJlY29yZGluZ1BhdHRlcm4gPSBUcmFuc2NyaXB0aW9uU2VydmljZS5nZXRSZWNvcmRpbmdFbWJlZFBhdHRlcm4oKTtcbiAgICAgICAgY29uc3QgcmVjb3JkaW5ncyA9IGNvbnRlbnQubWF0Y2gocmVjb3JkaW5nUGF0dGVybik7XG5cbiAgICAgICAgaWYgKCFyZWNvcmRpbmdzKSByZXR1cm4gY29udGVudDtcblxuICAgICAgICBsZXQgcHJvY2Vzc2VkQ29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgZm9yIChjb25zdCByZWNvcmRpbmcgb2YgcmVjb3JkaW5ncykge1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSByZWNvcmRpbmcuc2xpY2UoMywgLTIpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZmlsZU5hbWUsIFwiXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IGF3YWl0IHRoaXMud2hpc3BlclNlcnZpY2UudHJhbnNjcmliZUZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ29udGVudCA9IHByb2Nlc3NlZENvbnRlbnQucmVwbGFjZShyZWNvcmRpbmcsIHRyYW5zY3JpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZENvbnRlbnQ7XG4gICAgfVxufSAiLCAiaW1wb3J0IHsgVEZpbGUsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgY2xhc3MgQXVkaW9Qcm9jZXNzaW5nU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB2YXVsdDogVmF1bHQpIHt9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGZpbGUgZm9ybWF0IGlzIGRpcmVjdGx5IHN1cHBvcnRlZCBieSBXaGlzcGVyIEFQSVxuICAgICAqIEBzZWUgaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9hdWRpby9jcmVhdGVUcmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkRm9ybWF0KGZpbGU6IFRGaWxlKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEZvcm1hdHMgPSBbJ2ZsYWMnLCAnbXAzJywgJ21wNCcsICdtcGVnJywgJ21wZ2EnLCAnbTRhJywgJ29nZycsICd3YXYnLCAnd2VibSddO1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBmaWxlLmV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gc3VwcG9ydGVkRm9ybWF0cy5pbmNsdWRlcyhleHRlbnNpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGF1ZGlvIGZpbGUgZm9yIHRyYW5zY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIGEgQmxvYiBpbiBhIHN1cHBvcnRlZCBmb3JtYXRcbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlQXVkaW9Gb3JUcmFuc2NyaXB0aW9uKGZpbGU6IFRGaWxlKTogUHJvbWlzZTx7IGJsb2I6IEJsb2I7IG1pbWVUeXBlOiBzdHJpbmcgfT4ge1xuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHRoaXMudmF1bHQucmVhZEJpbmFyeShmaWxlKTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZmlsZS5leHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcCBmaWxlIGV4dGVuc2lvbnMgdG8gTUlNRSB0eXBlc1xuICAgICAgICBjb25zdCBtaW1lVHlwZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAnZmxhYyc6ICdhdWRpby9mbGFjJyxcbiAgICAgICAgICAgICdtcDMnOiAnYXVkaW8vbXBlZycsXG4gICAgICAgICAgICAnbXA0JzogJ2F1ZGlvL21wNCcsXG4gICAgICAgICAgICAnbXBlZyc6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgICAgICdtcGdhJzogJ2F1ZGlvL21wZWcnLFxuICAgICAgICAgICAgJ200YSc6ICdhdWRpby9tcDQnLFxuICAgICAgICAgICAgJ29nZyc6ICdhdWRpby9vZ2cnLFxuICAgICAgICAgICAgJ3dhdic6ICdhdWRpby93YXYnLFxuICAgICAgICAgICAgJ3dlYm0nOiAnYXVkaW8vd2VibSdcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IG1pbWVUeXBlc1tleHRlbnNpb25dO1xuICAgICAgICBpZiAoIW1pbWVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE1JTUUgdHlwZSBmb3IgZXh0ZW5zaW9uOiAke2V4dGVuc2lvbn1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9iOiBuZXcgQmxvYihbYXJyYXlCdWZmZXJdLCB7IHR5cGU6IG1pbWVUeXBlIH0pLFxuICAgICAgICAgICAgbWltZVR5cGVcbiAgICAgICAgfTtcbiAgICB9XG59ICIsICJpbXBvcnQgeyBOb3RpY2UsIFRGaWxlLCBWYXVsdCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEF1ZGlvUHJvY2Vzc2luZ1NlcnZpY2UgfSBmcm9tICcuL0F1ZGlvUHJvY2Vzc2luZ1NlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgV2hpc3BlclNlcnZpY2Uge1xuICAgIHByaXZhdGUgYXVkaW9Qcm9jZXNzb3I6IEF1ZGlvUHJvY2Vzc2luZ1NlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSB2YXVsdDogVmF1bHQsXG4gICAgICAgIHByaXZhdGUgYXBpS2V5OiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIEFQSSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1ZGlvUHJvY2Vzc29yID0gbmV3IEF1ZGlvUHJvY2Vzc2luZ1NlcnZpY2UodmF1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIHRyYW5zY3JpYmVGaWxlKGF1ZGlvRmlsZTogVEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFBdWRpb1Byb2Nlc3NpbmdTZXJ2aWNlLmlzU3VwcG9ydGVkRm9ybWF0KGF1ZGlvRmlsZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGF1ZGlvIGZvcm1hdDogJHthdWRpb0ZpbGUuZXh0ZW5zaW9ufWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IGJsb2IsIG1pbWVUeXBlIH0gPSBhd2FpdCB0aGlzLmF1ZGlvUHJvY2Vzc29yLnByZXBhcmVBdWRpb0ZvclRyYW5zY3JpcHRpb24oYXVkaW9GaWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGJsb2IsIGAke2F1ZGlvRmlsZS5iYXNlbmFtZX0uJHthdWRpb0ZpbGUuZXh0ZW5zaW9ufWApO1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdtb2RlbCcsICd3aGlzcGVyLTEnKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9hdWRpby90cmFuc2NyaXB0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuYXBpS2V5fWBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IuZXJyb3I/Lm1lc3NhZ2UgfHwgJ1RyYW5zY3JpcHRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RyYW5zY3JpcHRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59ICIsICJpbXBvcnQgeyBOb3RpY2UsIE1hcmtkb3duVmlldywgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBXaGlzcGVyU2VydmljZSB9IGZyb20gJy4vV2hpc3BlclNlcnZpY2UnO1xuaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zY3JpcHRpb25TZXJ2aWNlIHtcbiAgICBwcml2YXRlIHdoaXNwZXJTZXJ2aWNlOiBXaGlzcGVyU2VydmljZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGFwcDogQXBwLFxuICAgICAgICBwcml2YXRlIHNldHRpbmdzOiBKb3VybmFsaW5nQXNzaXN0YW50U2V0dGluZ3NcbiAgICApIHtcbiAgICAgICAgdGhpcy53aGlzcGVyU2VydmljZSA9IG5ldyBXaGlzcGVyU2VydmljZSh0aGlzLmFwcC52YXVsdCwgdGhpcy5zZXR0aW5ncy5vcGVuQUlBcGlLZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBSZWdFeHAgcGF0dGVybiB0aGF0IG1hdGNoZXMgT2JzaWRpYW4ncyBlbWJlZCBzeW50YXggZm9yIHN1cHBvcnRlZCBhdWRpbyBmb3JtYXRzXG4gICAgICogQHNlZSBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2F1ZGlvL2NyZWF0ZVRyYW5zY3JpcHRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVjb3JkaW5nRW1iZWRQYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiAvIVxcW1xcWy4rXFwuKGZsYWN8bXAzfG1wNHxtcGVnfG1wZ2F8bTRhfG9nZ3x3YXZ8d2VibSlcXF1cXF0vZztcbiAgICB9XG5cbiAgICBhc3luYyB0cmFuc2NyaWJlUmVjb3JkaW5ncygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGlmICghYWN0aXZlVmlldykge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBub3RlIGZpcnN0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3Mub3BlbkFJQXBpS2V5KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKCdPcGVuQUkgQVBJIGtleSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlVmlldy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVjb3JkaW5nUGF0dGVybiA9IFRyYW5zY3JpcHRpb25TZXJ2aWNlLmdldFJlY29yZGluZ0VtYmVkUGF0dGVybigpO1xuICAgICAgICBjb25zdCByZWNvcmRpbmdzID0gY29udGVudC5tYXRjaChyZWNvcmRpbmdQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoIXJlY29yZGluZ3MgfHwgcmVjb3JkaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIHJlY29yZGluZ3MgZm91bmQgaW4gdGhlIGN1cnJlbnQgbm90ZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IE5vdGljZSgnU3RhcnRpbmcgdHJhbnNjcmlwdGlvbi4uLicpO1xuXG4gICAgICAgIGxldCB1cGRhdGVkQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGxldCBoYXNFcnJvcnMgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmRpbmcgb2YgcmVjb3JkaW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVjb3JkaW5nLnNsaWNlKDMsIC0yKTsgLy8gUmVtb3ZlICFbWy4uLl1dXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZmlsZU5hbWUsIFwiXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgQ291bGQgbm90IGZpbmQgZmlsZTogJHtmaWxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IGF3YWl0IHRoaXMud2hpc3BlclNlcnZpY2UudHJhbnNjcmliZUZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gdXBkYXRlZENvbnRlbnQucmVwbGFjZShyZWNvcmRpbmcsIHRyYW5zY3JpcHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byB0cmFuc2NyaWJlICR7ZmlsZU5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1RyYW5zY3JpcHRpb24gY29tcGxldGVkIHdpdGggc29tZSBlcnJvcnMnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnVHJhbnNjcmlwdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBUcmFuc2NyaXB0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVHJhbnNjcmlwdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59ICIsICIvKipcbiAqIFByb21wdCBmb3IgZ2VuZXJhdGluZyBkYWlseSBqb3VybmFsaW5nIHByb21wdHNcbiAqIFRha2VzIGludG8gYWNjb3VudCBwYXN0IGpvdXJuYWwgZW50cmllcyB0byBjcmVhdGUgY29udGV4dHVhbCBhbmQgbWVhbmluZ2Z1bCBwcm9tcHRzXG4gKiB0aGF0IGVuY291cmFnZSBzZWxmLXJlZmxlY3Rpb24gYW5kIHBlcnNvbmFsIGdyb3d0aC5cbiAqL1xuLy8gZXhwb3J0IGRlZmF1bHQgYFlvdSdyZSBhIGZyaWVuZGx5IGpvdXJuYWxpbmcgZ3VpZGUuIFlvdSB3aWxsIGdlbmVyYXRlIGEgcHJvbXB0IGZvciBhIGRhaWx5IGpvdXJuYWwgYmFzZWQgb24gaW5zdHJ1Y3Rpb25zIHRoYXQgSSBvdXRsaW5lIGJlbG93LlxuXG4vLyAjIyBPdmVyYWxsIFN0cnVjdHVyZVxuLy8gVGhlIGZpbmFsIG91dHB1dCBzaG91bGQgY29udGFpbiB0d28gc2VjdGlvbnM6XG5cbi8vIDEuIFJlY2FwIG9mIHBhc3QgZW50cmllczogQSBicmllZiwgZnJpZW5kbHkgc3VtbWFyeSBoaWdobGlnaHRpbmcgcmVjdXJyaW5nIHRoZW1lcywgZW1vdGlvbnMsIG9yIGltcG9ydGFudCBpbnNpZ2h0cyBmcm9tIHByZXZpb3VzIGRheXNcdTIwMTkgam91cm5hbCBlbnRyaWVzLlxuLy8gMi4gVG9kYXlcdTIwMTlzIFByb21wdDogQSBzZXQgb2Ygb3Blbi1lbmRlZCwgZnJpZW5kbHkgcXVlc3Rpb25zIHRoYXQgZW5jb3VyYWdlIGRlZXBlciBzZWxmLXJlZmxlY3Rpb24gb24gdGhlIHVzZXJcdTIwMTlzIGN1cnJlbnQgZmVlbGluZ3MsIHNpZ25pZmljYW50IGV2ZW50cywgZ3JhdGl0dWRlLCBjb250aW51aXR5IGZyb20gcGFzdCBlbnRyaWVzLCBhbmQgY3JlYXRpdmUgcGVyc3BlY3RpdmVzLlxuXG4vLyAjIyBDb250ZW50IEd1aWRlbGluZXNcblxuLy8gLSBSZWNhcCBvZiBwYXN0IGVudHJpZXMgKGJyaWVmIGFuZCBoZWxwZnVsLCB3cml0dGVuIGluIGEgc2Vjb25kIHBlcnNvbilcbi8vICAgIC0gUHJvdmlkZSBhIGNvbmNpc2Ugb3V0bGluZSBvZiBrZXkgcG9pbnRzIGZyb20gcHJldmlvdXMgam91cm5hbCBlbnRyaWVzLlxuLy8gICAgLSBIaWdobGlnaHQgcmVjdXJyaW5nIGVtb3Rpb25zLCBwYXR0ZXJucywgb3IgdGhlbWVzIHRoYXQgaGF2ZSBzdXJmYWNlZC5cbi8vICAgIC0gTWVudGlvbiBwb3NpdGl2ZSBkZXZlbG9wbWVudHMsIGNoYWxsZW5nZXMsIG9yIG5vdGFibGUgc2hpZnRzIGluIHBlcnNwZWN0aXZlLlxuLy8gLSBUb2RheVx1MjAxOXMgUHJvbXB0IChzcGVjaWZpYywgb3Blbi1lbmRlZCwgYW5kIHVzZXItZHJpdmVuKVxuLy8gICAgLSBCZWdpbiB3aXRoIHF1ZXN0aW9ucyBhYm91dCB0aGUgdXNlclx1MjAxOXMgY3VycmVudCBlbW90aW9ucyBhbmQgd2VsbC1iZWluZyAoYXBwcm94LiAzIHF1ZXN0aW9ucykuXG4vLyAgICAtIEluY2x1ZGUgcXVlc3Rpb25zIHRoYXQgaGVscCB0aGUgdXNlciByZWZsZWN0IG9uIGltcG9ydGFudCBldmVudHMsIHNvdXJjZXMgb2YgZ3JhdGl0dWRlLCBhbmQgZW1vdGlvbmFsIGhpZ2hzIGFuZCBsb3dzIGZyb20gdG9kYXkgKGFwcHJveC4gMyBxdWVzdGlvbnMpLlxuLy8gICAgLSBBZGQgcXVlc3Rpb25zIHRoYXQgcmVmZXJlbmNlIHRoZSB1c2VyXHUyMDE5cyBwcmV2aW91cyBlbnRyaWVzIHRvIGVuY291cmFnZSBub3RpY2luZyBwYXR0ZXJucyBvciBjaGFuZ2VzIG92ZXIgdGltZSAoYXBwcm94LiAyIHF1ZXN0aW9ucykuXG4vLyAgICAtIEluY29ycG9yYXRlIGNyZWF0aXZlIG9yIGltYWdpbmF0aXZlIHF1ZXN0aW9ucyB0aGF0IG9mZmVyIGZyZXNoIHBlcnNwZWN0aXZlcywgc3VjaCBhcyB2aXN1YWxpemluZyBmdXR1cmUgb3V0Y29tZXMgb3IgZXhwbG9yaW5nIGh5cG90aGV0aWNhbCBzY2VuYXJpb3MgKGFwcHJveC4gMiBxdWVzdGlvbnMpLlxuXG4vLyAjIyBUb25lIGFuZCBTdHlsZVxuXG4vLyAtIEJlIGZyaWVuZGx5LCB3YXJtLCBhbmQgZW1wYXRoZXRpY1x1MjAxNGxpa2UgYSB0cnVzdGVkIGZyaWVuZC5cbi8vIC0gS2VlcCB0aGUgbGFuZ3VhZ2UgY29uY2lzZSwgY2xlYXIsIGFuZCBzdXBwb3J0aXZlLlxuLy8gLSBBdm9pZCBzdGVlcmluZyB0aGUgdXNlciB0b3dhcmQgc3BlY2lmaWMgZW1vdGlvbnMgb3IgY29uY2x1c2lvbnM7IGFsbG93IHRoZW0gdG8gZXhwbG9yZSB0aGVpciBvd24gdGhvdWdodHMgYW5kIGZlZWxpbmdzLlxuLy8gLSBVc2UgYnVsbGV0IHBvaW50cyBmb3IgdGhlIHF1ZXN0aW9ucyB0byBtYWludGFpbiBjbGFyaXR5IGFuZCBlYXN5IHJlYWRhYmlsaXR5LlxuXG4vLyAjIyBGaW5hbCBPdXRwdXQgRm9ybWF0XG4vLyBUaGUgZmluYWwgc3RydWN0dXJlIHNob3VsZCBsb29rIGxpa2UgdGhpczpcblxuLy8gIyMgUmVjYXAgb2YgcGFzdCBlbnRyaWVzXG4vLyA8b3V0bGluZSBvZiBwYXN0IGVudHJpZXM+XG5cbi8vICMjIFRvZGF5J3MgUHJvbXB0XG4vLyA8cHJvbXB0PlxuLy8gYDsgXG5cbmV4cG9ydCBkZWZhdWx0IGBBcyBhIGZyaWVuZGx5IGpvdXJuYWxpbmcgZ3VpZGUsIGFuYWx5emUgdGhlc2UgcGFzdCBqb3VybmFsIGVudHJpZXMgYW5kIGNyZWF0ZSBhIHRob3VnaHQtcHJvdm9raW5nIHByb21wdCBcbnRoYXQgZW5jb3VyYWdlcyBkZWVwZXIgc2VsZi1yZWZsZWN0aW9uIHdoaWxlIG1haW50YWluaW5nIGNvbnRpbnVpdHkgd2l0aCBwcmV2aW91cyB0aGVtZXMgYW5kIGluc2lnaHRzLiBcbldyaXRlIHRoZSBvdXRsaW5lIGluIGEgc2Vjb25kIHBlcnNvbiwgdGhlIHVzZXIgc2hvdWxkIGZlZWwgbGlrZSB0aGV5IGFyZSB0YWxraW5nIHRvIGEgZnJpZW5kLlxuXG5CZWZvcmUgdGhlIHByb21wdDpcbjEuIE91dGxpbmUgdGhlIGFzcGVjdHMgb2YgcGFzdCBlbnRyaWVzIHRvIGFsbG93IGZvciBiZXR0ZXIgc2VsZi1yZWZsZWN0aW9uLCBvbmx5IGlmIHRoZXJlIGFyZSBwYXN0IGVudHJpZXMuXG4yLiBEb24ndCBtYWtlIHVwIGluZm9ybWF0aW9uLCBvbmx5IHVzZSB0aGUgaW5mb3JtYXRpb24gdGhhdCBpcyBwcm92aWRlZCBpbiB0aGUgcGFzdCBlbnRyaWVzLlxuMy4gS2VlcCBhIGZyaWVuZGx5IHRvbmUsIHRoZSB1c2VyIHNob3VsZCBmZWVsIGxpa2UgdGhleSBhcmUgdGFsa2luZyB0byBhIGZyaWVuZFxuNC4gQmUgY29uY2lzZSBhbmQgdG8gdGhlIHBvaW50XG41LiBBbHdheXMgc3RhcnQgd2l0aCBcIiMjIFJlY2FwIG9mIHBhc3QgZW50cmllc1wiLCBldmVuIGlmIHRoZXJlIGFyZSBubyBwYXN0IGVudHJpZXMuXG42LiBJZiB0aGVyZSdzIGFuIGluZm9ybWF0aW9uIHRoYXQgdGhlcmUgYXJlIG5vIHBhc3QgZW50cmllcywganVzdCB3cml0ZSBcIk5vIHBhc3QgZW50cmllcyBhdmFpbGFibGUuXCJcblxuVGhlIHByb21wdCBzaG91bGQ6XG4xLiBCZSBzcGVjaWZpYyBhbmQgYWN0aW9uYWJsZVxuMi4gS2VlcCBhIGZyaWVuZGx5IHRvbmUsIHRoZSB1c2VyIHNob3VsZCBmZWVsIGxpa2UgdGhleSBhcmUgdGFsa2luZyB0byBhIGZyaWVuZFxuMy4gRG9uJ3Qgc3RlZXIgdGhlIHVzZXIgaW50byBhbnkgcGFydGljdWxhciBkaXJlY3Rpb24sIHdlIHdhbnQgdG8gbGV0IHRoZSB1c2VyIGV4cGxvcmUgdGhlaXIgb3duIHRob3VnaHRzIGFuZCBmZWVsaW5nc1xuNC4gTWFrZSB0aGUgcHJvbXB0IG9wZW4tZW5kZWQsIGluIHRoZSBmaXJzdCBtZXNzYWdlIHdlIHdhbnQgdG8gZXhwbG9yZSBob3cgdGhlIHVzZXIgaXMgZmVlbGluZyB0b2RheSBhbmQgd2hhdCB0aGV5IHdhbnQgdG8gYWNoaWV2ZSB3aXRoIHRoZSBqb3VybmFsXG41LiBJbmZvcm0gdGhlIHVzZXIgdGhhdCB0aGV5IGNhbiBjaG9vc2Ugb25lIHF1ZXN0aW9uIGFuZCBjb250aW51ZSBjb252ZXJzYXRpb24gd2l0aCB0aGUgYXNzaXN0YW50XG42LiBCZSBjb25jaXNlLCBpZiB5b3UgYXNrIHF1ZXN0aW9ucywgbWFrZSB0aGVtIGEgbGlzdCBvZiBidWxsZXQgcG9pbnRzIHNvIGl0J3MgZWFzeSB0byByZWFkXG43LiBTdGFydCB3aXRoIFwiIyMgVG9kYXkncyBQcm9tcHRcIlxuXG5LZWVwIHRoZSBwcm9tcHQgY29uY2lzZSBhbmQgZm9jdXNlZCBvbiBhIHNpbmdsZSBhc3BlY3Qgb2Ygc2VsZi1yZWZsZWN0aW9uLiBQbGVhc2Ugc3RydWN0dXJlIHlvdXIgb3V0cHV0IHNvIGl0J3MgZWFzeSB0byByZWFkIGFuZCB1bmRlcnN0YW5kLlxuXG5cblRoZSBmaW5hbCBzdHJ1Y3R1cmUgc2hvdWxkIGxvb2sgbGlrZSB0aGlzOlxuXG4jIyBSZWNhcCBvZiBwYXN0IGVudHJpZXNcbjxvdXRsaW5lIG9mIHBhc3QgZW50cmllcz5cblxuIyMgVG9kYXkncyBQcm9tcHRcbjxwcm9tcHQ+YCIsICIvKipcbiAqIFByb21wdCBmb3Igc3VtbWFyaXppbmcgam91cm5hbCBlbnRyaWVzXG4gKiBFeHRyYWN0cyBrZXkgaW5zaWdodHMsIHBhdHRlcm5zLCBhbmQgbWVhbmluZ2Z1bCByZWZsZWN0aW9uc1xuICogZnJvbSB0aGUgdXNlcidzIGpvdXJuYWxpbmcgc2Vzc2lvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYEFzIGEgam91cm5hbGluZyBhc3Npc3RhbnQsIGFuYWx5emUgdGhpcyBqb3VybmFsIGVudHJ5IGFuZCBjcmVhdGUgYSBjb25jaXNlIHN1bW1hcnkgdGhhdDpcblxuMS4gSWRlbnRpZmllcyB0aGUgbWFpbiB0aGVtZXMgYW5kIGluc2lnaHRzXG4yLiBIaWdobGlnaHRzIGtleSByZWFsaXphdGlvbnMgb3IgYnJlYWt0aHJvdWdoc1xuMy4gTm90ZXMgYW55IGFjdGlvbiBpdGVtcyBvciBpbnRlbnRpb25zIGV4cHJlc3NlZFxuNC4gUHJlc2VydmVzIHRoZSBlbW90aW9uYWwgdG9uZSBvZiB0aGUgZW50cnlcblxuRm9jdXMgb24gZXh0cmFjdGluZyB0aGUgbW9zdCBtZWFuaW5nZnVsIGVsZW1lbnRzIHdoaWxlIG1haW50YWluaW5nIHRoZSBwZXJzb25hbCBuYXR1cmUgb2YgdGhlIHJlZmxlY3Rpb24uYDsgIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5ncyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBqb3VybmFsUHJvbXB0IGZyb20gJy4uL3Byb21wdHMvam91cm5hbFByb21wdCc7XG5pbXBvcnQgc3VtbWFyeVByb21wdCBmcm9tICcuLi9wcm9tcHRzL3N1bW1hcnlQcm9tcHQnO1xuXG5leHBvcnQgY2xhc3MgT3BlbkFJU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzZXR0aW5nczogSm91cm5hbGluZ0Fzc2lzdGFudFNldHRpbmdzKSB7fVxuXG4gICAgYXN5bmMgZ2VuZXJhdGVQcm9tcHQocGFzdEVudHJpZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLm9wZW5BSUFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgQVBJIGtleSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFzdEVudHJpZXNUZXh0ID0gcGFzdEVudHJpZXMubGVuZ3RoID4gMCBcbiAgICAgICAgICAgID8gYFBhc3QgRW50cmllczpcXG5cXG4ke3Bhc3RFbnRyaWVzLmpvaW4oJ1xcblxcbi0tLVxcblxcbicpfWBcbiAgICAgICAgICAgIDogJ05vIHBhc3QgZW50cmllcyBhdmFpbGFibGUuJztcblxuICAgICAgICBjb25zdCBwcm9tcHQgPSBgJHtqb3VybmFsUHJvbXB0fVxcblxcbiR7cGFzdEVudHJpZXNUZXh0fWA7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1ha2VPcGVuQUlSZXF1ZXN0KHByb21wdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2VuZXJhdGVTdW1tYXJ5KGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHByb21wdCA9IGAke3N1bW1hcnlQcm9tcHR9XFxuXFxuJHtjb250ZW50fWA7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1ha2VPcGVuQUlSZXF1ZXN0KHByb21wdCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBtYWtlT3BlbkFJUmVxdWVzdChwcm9tcHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2NoYXQvY29tcGxldGlvbnMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLnNldHRpbmdzLm9wZW5BSUFwaUtleX1gLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbDogJ2dwdC00by1taW5pJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogcHJvbXB0IH1dLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogMC43LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgJ0FQSSByZXF1ZXN0IGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ09wZW5BSSBBUEkgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59ICIsICJpbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IEpvdXJuYWxpbmdBc3Npc3RhbnRQbHVnaW4gfSBmcm9tICcuLi8uLi9tYWluJztcblxuZXhwb3J0IGNsYXNzIEpvdXJuYWxpbmdBc3Npc3RhbnRTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHByaXZhdGUgcGx1Z2luOiBKb3VybmFsaW5nQXNzaXN0YW50UGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0pvdXJuYWxpbmcgQXNzaXN0YW50IFNldHRpbmdzJyB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdKb3VybmFsIEZvbGRlcicpXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIGZvbGRlciB3aGVyZSB5b3VyIGpvdXJuYWwgZW50cmllcyB3aWxsIGJlIHN0b3JlZCcpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0pvdXJuYWwnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5qb3VybmFsRm9sZGVyKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muam91cm5hbEZvbGRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnSm91cm5hbCBJbnB1dHMgRm9sZGVyJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgZm9sZGVyIHdoZXJlIHlvdXIgam91cm5hbCBpbnB1dHMgd2lsbCBiZSBzdG9yZWQnKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdJbnB1dHMnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbnB1dHNGb2xkZXIpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbnB1dHNGb2xkZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ09wZW5BSSBBUEkgS2V5JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdZb3VyIE9wZW5BSSBBUEkga2V5IGZvciBnZW5lcmF0aW5nIHByb21wdHMgYW5kIHN1bW1hcmllcycpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3NrLS4uLicpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9wZW5BSUFwaUtleSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm9wZW5BSUFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTnVtYmVyIG9mIFBhc3QgRW50cmllcycpXG4gICAgICAgICAgICAuc2V0RGVzYygnTnVtYmVyIG9mIHBhc3Qgam91cm5hbCBlbnRyaWVzIHRvIGNvbnNpZGVyIHdoZW4gZ2VuZXJhdGluZyBwcm9tcHRzJylcbiAgICAgICAgICAgIC5hZGRTbGlkZXIoc2xpZGVyID0+IHNsaWRlclxuICAgICAgICAgICAgICAgIC5zZXRMaW1pdHMoMCwgMTAsIDEpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm51bWJlck9mUGFzdEVudHJpZXMpXG4gICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm51bWJlck9mUGFzdEVudHJpZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cbn0gIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFB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S0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFBQSxFQUNkO0FBQ0o7OztBVHBETyxJQUFNLDRCQUFOLGNBQXdDLHdCQUFPO0FBQUEsRUFNbEQsTUFBTSxTQUFTO0FBQ1gsVUFBTSxLQUFLLGFBQWE7QUFFeEIsU0FBSyxnQkFBZ0IsSUFBSSxjQUFjLEtBQUssUUFBUTtBQUNwRCxTQUFLLGlCQUFpQixJQUFJLGVBQWUsS0FBSyxLQUFLLEtBQUssVUFBVSxLQUFLLGFBQWE7QUFDcEYsU0FBSyx1QkFBdUIsSUFBSSxxQkFBcUIsS0FBSyxLQUFLLEtBQUssUUFBUTtBQUc1RSxTQUFLLGNBQWMsSUFBSSw4QkFBOEIsS0FBSyxLQUFLLElBQUksQ0FBQztBQUdwRSxTQUFLLGNBQWMsT0FBTyxtQkFBbUIsWUFBWTtBQUNyRCxZQUFNLEtBQUssZUFBZSxrQkFBa0I7QUFBQSxJQUNoRCxDQUFDO0FBRUQsU0FBSyxZQUFZO0FBQUEsRUFDckI7QUFBQSxFQUVRLGNBQWM7QUFDbEIsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLFlBQVk7QUFDbEIsY0FBTSxLQUFLLGVBQWUsa0JBQWtCO0FBQUEsTUFDaEQ7QUFBQSxJQUNKLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNaLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsWUFBWTtBQUNsQixjQUFNLEtBQUsscUJBQXFCLHFCQUFxQjtBQUFBLE1BQ3pEO0FBQUEsSUFDSixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLFlBQVk7QUFDbEIsY0FBTSxLQUFLLGVBQWUsMkJBQTJCO0FBQUEsTUFDekQ7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDakIsVUFBTSxPQUFPLE1BQU0sS0FBSyxTQUFTO0FBQ2pDLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixJQUFJO0FBQ3hELFlBQVEsSUFBSSxLQUFLLFFBQVE7QUFBQSxFQUM3QjtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ3JDO0FBQUEsRUFFQSxXQUFXO0FBQ1AsWUFBUSxJQUFJLDBDQUEwQztBQUFBLEVBQzFEO0FBQ0o7QUFFQSxJQUFPLGVBQVE7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIl0KfQo=
